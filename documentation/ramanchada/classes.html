<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.3.0" />
    <title>ramanchada.classes API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../ramanchada.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;ramanchada</a>


                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Curve">Curve</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Curve.__init__">Curve</a>
                        </li>
                        <li>
                                <a class="function" href="#Curve.plot">plot</a>
                        </li>
                        <li>
                                <a class="function" href="#Curve.normalize">normalize</a>
                        </li>
                        <li>
                                <a class="function" href="#Curve.smooth">smooth</a>
                        </li>
                        <li>
                                <a class="function" href="#Curve.x_crop">x_crop</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Spectrum">Spectrum</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Spectrum.__init__">Spectrum</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.invert">invert</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.peaks">peaks</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.show_bands">show_bands</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.fit_baseline">fit_baseline</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.remove_baseline">remove_baseline</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.interpolate_x">interpolate_x</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.hqi">hqi</a>
                        </li>
                        <li>
                                <a class="function" href="#Spectrum.math">math</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RamanSpectrum">RamanSpectrum</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RamanSpectrum.__init__">RamanSpectrum</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.add_metadata">add_metadata</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.calibrate">calibrate</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.make_x_calibration">make_x_calibration</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.calibrate_y">calibrate_y</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.make_y_calibration">make_y_calibration</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.deconvolve_MTF">deconvolve_MTF</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.make_res_calibration">make_res_calibration</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.set_resolution">set_resolution</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.fit_xrays">fit_xrays</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.remove_xrays">remove_xrays</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanSpectrum.get_snr">get_snr</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RamanChada">RamanChada</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RamanChada.__init__">RamanChada</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanChada.show_log">show_log</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanChada.rewind">rewind</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanChada.commit">commit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#make_test_RamanChada">make_test_RamanChada</a>
            </li>
            <li>
                    <a class="class" href="#SpectrumGroup">SpectrumGroup</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SpectrumGroup.__init__">SpectrumGroup</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.add">add</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.plot">plot</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.to_array">to_array</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.process">process</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.make_mtf_calibration">make_mtf_calibration</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.round_robin">round_robin</a>
                        </li>
                        <li>
                                <a class="function" href="#SpectrumGroup.generate_labels">generate_labels</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RamanGroup">RamanGroup</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RamanGroup.__init__">RamanGroup</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.add_one">add_one</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.add">add</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.set_targets">set_targets</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.extract">extract</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.clone">clone</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.process">process</a>
                        </li>
                        <li>
                                <a class="variable" href="#RamanGroup.x">x</a>
                        </li>
                        <li>
                                <a class="variable" href="#RamanGroup.y">y</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanGroup.plot">plot</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RamanCalibration">RamanCalibration</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RamanCalibration.__init__">RamanCalibration</a>
                        </li>
                        <li>
                                <a class="variable" href="#RamanCalibration.test_x">test_x</a>
                        </li>
                        <li>
                                <a class="function" href="#RamanCalibration.show">show</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RamanMTF">RamanMTF</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RamanMTF.__init__">RamanMTF</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RamanCTF">RamanCTF</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RamanCTF.__init__">RamanCTF</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#MetaData">MetaData</a>
                            <ul class="memberlist">
                </ul>

            </li>
            <li>
                    <a class="function" href="#spectrum_to_frame">spectrum_to_frame</a>
            </li>
            <li>
                    <a class="function" href="#spectrum_to_series">spectrum_to_series</a>
            </li>
            <li>
                    <a class="function" href="#line_to_spectrum">line_to_spectrum</a>
            </li>
            <li>
                    <a class="function" href="#process_DF">process_DF</a>
            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../ramanchada.html">ramanchada</a><wbr>.classes    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1"># Written by Bastian Barton, Fraunhofer LBF, as part of the CHARISMA Work Package 4</span>
<span class="c1"># Version 0.2 (Prototype), May 5, 2021</span>
<span class="c1"># All rights reserved. The code may be used for purposes of CHARISMA as defined in the Consortium Agreement.</span>

<span class="c1"># external imports</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">matplotlib.style</span> <span class="k">as</span> <span class="nn">plot_style</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="c1"># ramanchada imports</span>
<span class="kn">from</span> <span class="nn">ramanchada.decorators</span> <span class="kn">import</span> <span class="n">specstyle</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">change_y</span><span class="p">,</span> <span class="n">change_x</span><span class="p">,</span> <span class="n">mark_peaks</span>
<span class="kn">from</span> <span class="nn">ramanchada.pre_processing.baseline</span> <span class="kn">import</span> <span class="n">baseline_model</span><span class="p">,</span> <span class="n">xrays</span>
<span class="kn">from</span> <span class="nn">ramanchada.pre_processing.denoise</span> <span class="kn">import</span> <span class="n">smooth_curve</span>
<span class="kn">from</span> <span class="nn">ramanchada.file_io.io</span> <span class="kn">import</span> <span class="n">import_native</span><span class="p">,</span>\
    <span class="n">read_chada</span><span class="p">,</span> <span class="n">create_chada_from_native</span><span class="p">,</span> <span class="n">commit_chada</span>
<span class="kn">from</span> <span class="nn">ramanchada.analysis.peaks</span> <span class="kn">import</span> <span class="n">find_spectrum_peaks</span><span class="p">,</span> <span class="n">fit_spectrum_peaks_pos</span><span class="p">,</span> <span class="n">find_spectrum_peaks_cwt</span>
<span class="kn">from</span> <span class="nn">ramanchada.analysis.signal</span> <span class="kn">import</span> <span class="n">snr</span>
<span class="kn">from</span> <span class="nn">ramanchada.utilities</span> <span class="kn">import</span> <span class="n">hqi</span><span class="p">,</span> <span class="n">lims</span><span class="p">,</span> <span class="n">interpolation_within_bounds</span><span class="p">,</span> <span class="n">labels_from_filenames</span>
<span class="kn">from</span> <span class="nn">ramanchada.calibration.calibration</span> <span class="kn">import</span> <span class="n">raman_x_calibration</span><span class="p">,</span> <span class="n">raman_x_calibration_from_spectrum</span><span class="p">,</span> <span class="n">raman_y_calibration_from_spectrum</span><span class="p">,</span>\
    <span class="n">deconvolve_mtf</span><span class="p">,</span> <span class="n">relative_ctf</span><span class="p">,</span> <span class="n">apply_relative_ctf</span><span class="p">,</span> <span class="n">raman_mtf_from_psfs</span><span class="p">,</span> <span class="n">extract_xrays</span>

    
<span class="k">class</span> <span class="nc">Curve</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic Data class with designated x and y columns. Can be spectra, distributions, chromatograms, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt;Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt;Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt;Name of the column holding the y data.  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># data is a pd.DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x_column_name</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y_column_name</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1"> points generated </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>\
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>\
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">info</span>
    <span class="nd">@specstyle</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the curve, i.e. the y data against x data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;snv&#39;</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize y data by subtracting a constant, followed by dividing by another constant.</span>
<span class="sd">        Both constants are calculated from the y data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Normalization method as described in *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;snv&#39;: standard normal variate - subtract mean, divide by standard deviation  </span>
<span class="sd">            - &#39;vector&#39;: vector normalization  - subtract 0, divide by vector norm   </span>
<span class="sd">            - &#39;minmax&#39;: min-max scaling - subtract minimun, divide by maximum  </span>
<span class="sd">            - &#39;area&#39;: integrated intensity scaling - subtract minimun, divide by mean  </span>
<span class="sd">            The default is &#39;snv&#39;.  </span>
<span class="sd">            </span>
<span class="sd">        x_min : double, optional</span>
<span class="sd">            &gt; Lower x boundary of interval where constants are determined from. The default is -1e9.</span>
<span class="sd">            </span>
<span class="sd">        x_max : double, optional. </span>
<span class="sd">            &gt; Upper x boundary of interval where constants are determined from. The default is 1e9.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;snv&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">],</span>
                   <span class="s1">&#39;vector&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">],</span>
                   <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">],</span>
                   <span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">]}</span>
        <span class="c1"># normalization is measured within specified interval</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">methods</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">0</span><span class="p">](</span><span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">/=</span> <span class="n">methods</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing / denoising of x data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Smoothing method. Can be one of the following:</span>

<span class="sd">        **- &#39;sg&#39;: Savitzky-Golay filter** - see scipy.signal.savgol_filter</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        window_length : int, optional</span>
<span class="sd">        &gt; Window Length for Savitzky-Golay filter. The default is 11.</span>
<span class="sd">        </span>
<span class="sd">        polyorder : int, optional</span>
<span class="sd">        &gt; Polynomial order for Savitzky-Golay filter. The default is 3.</span>

<span class="sd">        **- &#39;wiener&#39;: Wien filter** - see scipy.signal.wiener</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        mysize : int or array_like, optional</span>
<span class="sd">        &gt; A scalar or an N-length list giving the size of the Wiener filter window in each dimension. Elements of mysize should be odd. If mysize is a scalar, then this scalar is used as the size in each dimension.</span>

<span class="sd">        noise : float, optional</span>
<span class="sd">        &gt; The noise-power to use. If None, then noise is estimated as the average of the local variance of the input.</span>

<span class="sd">        **- &#39;median&#39;: median filter** - see scipy.signal.medfilt</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        kernel_size : array_like, optional</span>
<span class="sd">        &gt; A scalar or an N-length list giving the size of the median filter window in each dimension. Elements of kernel_size should be odd. If kernel_size is a scalar, then this scalar is used as the size in each dimension. Default size is 3 for each dimension.</span>

<span class="sd">        **- &#39;gauss&#39;: Gauss filter** - see scipy.ndimage.gaussian_filter1d</span>

<span class="sd">        sigma : scalar</span>
<span class="sd">        &gt; Standard deviation for Gaussian kernel</span>

<span class="sd">        **- &#39;lowess&#39;: Locally Weighted Scatterplot Smoothing (LOWESS)** - see statsmodels.nonparametric.smoothers_lowess.lowess</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        span : float</span>
<span class="sd">        &gt; Width of interval (in channels) to use for estimating each y-value.</span>

<span class="sd">        **- &#39;boxcar&#39;: filter by rectangular window or Dirichlet window**</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        box_pts : int</span>
<span class="sd">        &gt; Number of points in the output window. If zero or less, an empty array is returned.</span>

<span class="sd">        The default is &#39;sg&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;window_length&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;polyorder&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">smooth_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">x_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Crop data on x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_min : double</span>
<span class="sd">            &gt; Lower x boundary of interval in x units</span>
<span class="sd">            </span>
<span class="sd">        x_max : double</span>
<span class="sd">            &gt; Upper x boundary of interval in x units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">Spectrum</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A curve with peaks that can be located and analyzed.</span>
<span class="sd">    Inherits from Curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;spectral index&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;intensity [a.u.]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt; Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the y data.</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; Label for x data. The default is &#39;spectral index&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : TYPE, optional</span>
<span class="sd">            &gt; Label for y data The default is &#39;intensity [a.u.]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">y_label</span>
        
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flips y axis by inversion followed by minimum subtraction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">cwt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fitmethod</span> <span class="o">=</span> <span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cwt_width</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
              <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;prominence&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automated detection and analysis of peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_min : double, optional</span>
<span class="sd">            &gt; Lower x boundary of search interval in x units. The default is -1e9.</span>
<span class="sd">            </span>
<span class="sd">        x_max : double, optional</span>
<span class="sd">            &gt; Upper x boundary of search interval in x units. The default is 1e9.</span>
<span class="sd">            </span>
<span class="sd">        fit : bool, optional</span>
<span class="sd">            &gt; True if peak parameters should be determined by fitting an analytical model. The default is True.</span>
<span class="sd">            </span>
<span class="sd">        fitmethod : str, optional</span>
<span class="sd">            &gt; Model to fit to each peak.   </span>
<span class="sd">            - &#39;par&#39;: parabola  </span>
<span class="sd">            - &#39;voigt&#39;: Voigt distribution  </span>
<span class="sd">            - &#39;vg&#39;: Sum of independent Gauss + Voigt model  </span>
<span class="sd">            The default is &#39;voigt&#39;.</span>
<span class="sd">            </span>
<span class="sd">        interval_width : double, optional</span>
<span class="sd">            &gt; The interval width, in FWHMs, on which each peak is fitted. The default is 2.</span>
<span class="sd">            </span>
<span class="sd">        sort_by : str, optional</span>
<span class="sd">            &gt; The column after which peaks are sorted in the .bands attribute. The default is &#39;prominence&#39;.</span>
<span class="sd">            </span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            &gt; True if fits should be plotted with the data for each peak. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cwt</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="n">find_spectrum_peaks_cwt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">cwt_width</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;intensity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="n">find_spectrum_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="n">sort_by</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
            <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="n">fit_spectrum_peaks_pos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="n">fitmethod</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="n">interval_width</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted FWHM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas</span>
    <span class="nd">@specstyle</span>
    <span class="nd">@mark_peaks</span>
    <span class="k">def</span> <span class="nf">show_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bands&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No bands located yet. Use *.peaks()* first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">style</span>
    <span class="k">def</span> <span class="nf">fit_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a flourescent background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Model fitting method as described in  </span>
<span class="sd">            *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;als&#39;: Asymmetric least squares.  </span>
<span class="sd">            After *He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.*  </span>
<span class="sd">            - &#39;snip&#39;: statistics-sensitive non-linear iterative peak clipping.  </span>
<span class="sd">            After *Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.*    </span>
<span class="sd">            The default is &#39;als&#39;.</span>
<span class="sd">            </span>
<span class="sd">        lam : double, optional</span>
<span class="sd">            &gt; lambda parameter for ALS. The default is 1e5.</span>
<span class="sd">            </span>
<span class="sd">        p : double, optional</span>
<span class="sd">            &gt; p parameter for ALS. The default is 0.001.</span>
<span class="sd">            </span>
<span class="sd">        niter : int, optional</span>
<span class="sd">            &gt; Number of iterations. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">        smooth : int, optional</span>
<span class="sd">            &gt; Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">remove_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits and removes a flourescent background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Model fitting method as described in  </span>
<span class="sd">            *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;als&#39;: Asymmetric least squares.  </span>
<span class="sd">            After *He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.*  </span>
<span class="sd">            - &#39;snip&#39;: statistics-sensitive non-linear iterative peak clipping.  </span>
<span class="sd">            After *Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.*    </span>
<span class="sd">            The default is &#39;als&#39;.</span>
<span class="sd">            </span>
<span class="sd">        lam : double, optional</span>
<span class="sd">            &gt; lambda parameter for ALS. The default is 1e5.</span>
<span class="sd">            </span>
<span class="sd">        p : double, optional</span>
<span class="sd">            &gt; p parameter for ALS. The default is 0.001.</span>
<span class="sd">            </span>
<span class="sd">        niter : int, optional</span>
<span class="sd">            &gt; Number of iterations. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">        smooth : int, optional</span>
<span class="sd">            &gt; Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_baseline</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span>
            
    <span class="nd">@change_x</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">interpolate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate spectrum onto the x axis of a reference spectrum. If no reference is given, the x axis is interpolated to an increment of 1.0 units (usually rel 1/cm).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_spectrum : Spectrum, optional</span>
<span class="sd">            &gt; Reference spectrum. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no reference is given, just sample to one wavenumber</span>
        <span class="k">if</span> <span class="n">reference_spectrum</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">reference_spectrum</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># reference_spectrum is a Spectrum</span>
        <span class="n">f_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f_inter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">hqi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Hit Quality Index after *Rodriguez, J. D., Westenberger, B. J., Buhse, L. F., &amp; Kauffman, J. F. (2011b). Standardization of Raman spectra for transfer of spectral libraries across different instruments. Analyst, 136(20), 4232â€“4240. https://doi.org/10.1039/c1an15636e*  </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt; reference_spectrum : Spectrum</span>
<span class="sd">            Reference Spectrum with which HQI is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        double</span>
<span class="sd">            &gt; Hit Quality Index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy to avoid changing data upon interpolate_x</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="n">reference_spectrum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hqi</span><span class="p">(</span><span class="n">self_copy</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
            <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span>
            <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RamanSpectrum</span><span class="p">(</span><span class="n">Spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for a Raman Spectrum, which can have metadata and can be calibrated.</span>
<span class="sd">    Inherits from *Spectrum*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">,</span>
                 <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;Raman Shift [rel 1/cm]&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;intensity [a.u.]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt; Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the y data.</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; Label for x data. The default is &#39;spectral index&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : TYPE, optional</span>
<span class="sd">            &gt; Label for y data The default is &#39;intensity [a.u.]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">y_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">add_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds metadata to a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_dict : dict</span>
<span class="sd">            &gt; Python dictionary, containing pairs of key: value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meta_dict</span><span class="p">)</span>
    <span class="nd">@change_x</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration : RamanCalibration</span>
<span class="sd">            &gt; Calibration object for the x  axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate Raman shift corrections</span>
        <span class="n">x_shifts</span> <span class="o">=</span> <span class="n">calibration</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Substitute with new x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x_shifts</span>
        <span class="c1"># Make sure x values remain sorted</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">make_x_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span> <span class="o">=</span> <span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">peak_pos</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an x axis calibration, either to a RamanSpectrum or a list of exact reference peak positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum or list</span>
<span class="sd">            &gt; Reference for calibration.</span>
<span class="sd">            If RamanSpectrum, the reference must be a spectrum recorded using the same sample, and calibrated.</span>
<span class="sd">            If list, the reference must be a list of exact peak positions.</span>
<span class="sd">            </span>
<span class="sd">        fitmethod : str, optional</span>
<span class="sd">            &gt; Model to fit to each peak of Target and Reference  </span>
<span class="sd">            - &#39;par&#39;: parabola  </span>
<span class="sd">            - &#39;voigt&#39;: Voigt distribution  </span>
<span class="sd">            - &#39;vg&#39;: Sum of independent Gauss + Voigt model  </span>
<span class="sd">            The default is &#39;voigt&#39;.</span>

<span class="sd">        peak_pos : list, optional</span>
<span class="sd">            &gt; Only if reference is a RamanSpectrum: peak positions that should be fit and included in the calibration.</span>
<span class="sd">            The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCalibration</span>
<span class="sd">            &gt; Calibration object containing the relative shifts as well as a polynomial interpolation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Returns a RamanCalibration</span>
        <span class="c1"># If a Raman spectrum is given as refernece</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RamanSpectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;RamanChada&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">raman_x_calibration_from_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">peak_pos</span><span class="o">=</span><span class="n">peak_pos</span><span class="p">)</span>
        <span class="c1"># If a list of peak positions is given</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">raman_x_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">calibrate_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the y axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration : RamanCalibration</span>
<span class="sd">            &gt; Calibration object for the y  axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate Raman gain corrections</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">calibration</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">gain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calibration not in data range!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Apply gain correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">gain</span>
    <span class="k">def</span> <span class="nf">make_y_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an y axis calibration to a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum</span>
<span class="sd">            &gt; The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</span>
<span class="sd">            </span>
<span class="sd">        x_min : double</span>
<span class="sd">            &gt; Lower x boundary of calibration interval in x units</span>
<span class="sd">            </span>
<span class="sd">        x_max : double</span>
<span class="sd">            &gt; Upper x boundary of calibration interval in x units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCalibration</span>
<span class="sd">            &gt; Calibration object containing the relative gain as well as a polynomial interpolation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">raman_y_calibration_from_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">x_max</span><span class="p">)</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">deconvolve_MTF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mtf</span><span class="p">,</span> <span class="n">gauss_filter_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolves an MTF from a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mtf : RamanMTF</span>
<span class="sd">            &gt; MTF object containing the MTF model in Fourier space.</span>
<span class="sd">            </span>
<span class="sd">        gauss_filter_sigma : double, optional</span>
<span class="sd">            &gt; Sigma of a Gauss filter applied after deconvolution to reduce excessive noise. The default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">deconvolve_mtf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">mtf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gauss_filter_sigma</span><span class="o">=</span><span class="n">gauss_filter_sigma</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">make_res_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the resolution (peak broadening) to that of a reference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum</span>
<span class="sd">            &gt; The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCTF</span>
<span class="sd">            &gt; Object containing the model of ther relative point spread function in Fourier space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use copies to not mess with data here</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">tar</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># crop ref to intersection</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">tar</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()])</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">tar</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">x_crop</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="c1"># interpolate both to common x with delta = 1/cm</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="c1"># normalize</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
        <span class="c1"># calc rel. CTF</span>
        <span class="n">rel_k</span><span class="p">,</span> <span class="n">rel_ctf</span> <span class="o">=</span> <span class="n">relative_ctf</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tar</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ctf_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">ctf_data</span><span class="p">[</span><span class="s1">&#39;spatial frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_k</span>
        <span class="n">ctf_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_ctf</span>
        <span class="k">return</span> <span class="n">RamanCTF</span><span class="p">(</span><span class="n">ctf_data</span><span class="p">)</span>
    <span class="nd">@change_x</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">set_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a relative CTF to a RamanSpectrum</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rel_ctf : RamanCTF</span>
<span class="sd">            &gt; Object containing the model of ther relative point spread function in Fourier space.</span>
<span class="sd">            When applied, the resolution is approximated to that of the reference instrument with which the CTF was calibrated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x values must be equally spaced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">apply_relative_ctf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a model for cosmic rays (x rays) to the y data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xrays</span> <span class="o">=</span> <span class="n">xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">remove_xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes cosmic rays by subtracting the model stored in .xrays (if it exists).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xrays&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xrays</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">get_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximates the signal-to-noise ratio of a Raman spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : double</span>
<span class="sd">            &gt; Approximation for SNR.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">snr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        
<span class="k">class</span> <span class="nc">RamanChada</span><span class="p">(</span><span class="n">RamanSpectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raman CHADA file with logging and saving to disc. Inherits from RamanSpectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;Raman shift [rel. 1/cm]&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;counts [1]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_path : str</span>
<span class="sd">            &gt; Path to spectrum data file that is to be read.</span>
<span class="sd">            If extension is .cha, an existing CHADA file will be opened.</span>
<span class="sd">            If not, a native data file is imported and a CHADA file with the same name generated in the same directory.</span>
<span class="sd">            </span>
<span class="sd">        commit : str, optional</span>
<span class="sd">            &gt; If specified, the data of the specific commit is loaded rather than the most recent. The default is [].</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; See RamanSpectrum. The default is &#39;Raman shift [rel. 1/cm]&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : str, optional</span>
<span class="sd">            &gt; See RamanSpectrum. The default is &#39;counts [1]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If file is not CHADA, create from native</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">source_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.cha&#39;</span><span class="p">:</span>
            <span class="n">source_path</span> <span class="o">=</span> <span class="n">create_chada_from_native</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">read_chada</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">source_path</span>
        <span class="c1"># Initialize log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Save original state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">show_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows the log.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">,</span> <span class="s1">&#39;keyword args&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rewind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the object and data to a past state as listed in the log.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : signed int</span>
<span class="sd">            &gt; If positive, it sets the object to a past state as listed in the log.</span>
<span class="sd">            If negative, resets the object by -state steps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get log up to state</span>
        <span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">[:</span><span class="n">state</span><span class="p">]</span>
        <span class="c1"># empty log (gets populated upon execution of methods)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
            <span class="c1"># Make function from log info</span>
            <span class="c1"># log lines are l = [&#39;time&#39;, &#39;methodname&#39;, &#39;args&#39;, &#39;kwargs&#39;]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commit_text</span><span class="o">=</span><span class="s2">&quot;current&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a commit to the CHADA file by saving the current state to a new dataset within the existing HDF5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        commit : str, optional</span>
<span class="sd">            &gt; Name as reference for commit. The default is &#39;current&#39;.</span>
<span class="sd">            Cannot be &#39;raw&#39;, since the first commit after conversion (the raw data) cannot be edited.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commit_chada</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commit_text</span><span class="p">)</span>
        <span class="c1"># Initialize log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">make_test_RamanChada</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates test spctrum</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    RamanChada</span>
<span class="sd">        &gt; Spectrum of a organic compound with several peaks as RamanChada.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;testdata&quot;</span><span class="p">,</span> <span class="s2">&quot;200218-17.wdf&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">RamanChada</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    
<span class="k">class</span> <span class="nc">SpectrumGroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group of spectra for comparison and multivariate analysis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : RamanSpectrum, optional</span>
<span class="sd">            &gt; Raman spectra to be contained upon initialization. The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info1</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> containing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">)</span><span class="si">}</span><span class="s1"> objects.&#39;</span>
        <span class="n">info2</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Object type(s): </span><span class="si">{</span><span class="nb">set</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info1</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">info2</span>
        <span class="k">return</span> <span class="n">info</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a RamanSpectrum to the Group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectrum : RamanSpectrum</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y_label</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="s1">&#39;meta&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">))</span>
    <span class="nd">@specstyle</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot all contained spectra into a single graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leg : bool, optional</span>
<span class="sd">            &gt; True if a legend should be shown. The default is True.</span>
<span class="sd">            If unspecified, legend labelsare set to file names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leg</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="c1">#    - add_labels</span>
<span class="c1">#    - add_targets</span>
    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_increment</span><span class="o">=</span><span class="mf">.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate all spectra to a common x axis and Export as Numpy array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_increment : double, optional</span>
<span class="sd">            &gt; Spectral increment (resolution) of the common x axis. The default is 0.5.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Matrix containing all spectra in Group as lines.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Boundaries of intersection</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span>
        <span class="c1"># Make common x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">x_increment</span><span class="p">)</span>
        <span class="c1"># for all</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># interpolate to x</span>
            <span class="n">f_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_inter</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a specified method to separately to each spectrum in the group.</span>
<span class="sd">        Example:</span>
<span class="sd">            </span>
<span class="sd">            G.process(&#39;x_crop&#39;, 500, 1800)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            &gt; Name of method to be applied</span>
<span class="sd">            </span>
<span class="sd">        *args</span>
<span class="sd">            &gt; Non-keyword agruments for method. Refer to method documentation.</span>
<span class="sd">            </span>
<span class="sd">        **kwargs : TYPE</span>
<span class="sd">            &gt; Keyword agruments for method. Refer to method documentation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for indexed spectra</span>
        <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># search for method in class object</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="c1"># Apply method with args</span>
                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span> <span class="k">raise</span> <span class="n">err</span>
    <span class="k">def</span> <span class="nf">make_mtf_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract x rays from grouped spectra and generate a model from the average MTF in Fourier space.</span>
<span class="sd">        This is suitable if the Group consists of a time series, which is likely to contain one or more x rays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanMTF</span>
<span class="sd">            &gt; MTF model in Fourier space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xray_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="n">xray_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extract_xrays</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xray_list</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; xrays found in Group&#39;</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">mtf</span> <span class="o">=</span> <span class="n">raman_mtf_from_psfs</span><span class="p">(</span><span class="n">xray_list</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculated MTF with amlitude = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mtf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; at full Nyquist.&#39;</span><span class="p">)</span>
        <span class="n">mtf_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">mtf_data</span><span class="p">[</span><span class="s1">&#39;Nyquist frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">mtf_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtf</span>
        <span class="k">return</span> <span class="n">RamanMTF</span><span class="p">(</span><span class="n">mtf_data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">round_robin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_pos</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the x position of a list of specified peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fitmethod : str</span>
<span class="sd">            &gt; Name of peak fit model to be applied</span>
<span class="sd">            </span>
<span class="sd">        interval_width : int</span>
<span class="sd">            &gt; Interval in multiples of FWHM around the peak to be used for peak fitting.  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            &gt; *DataFrame* containing standard and fitted peak positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># Fit peaks for each spectrum</span>
            <span class="n">s</span><span class="o">.</span><span class="n">peaks</span><span class="p">(</span><span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="n">interval_width</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Select peak closest to indicated reference pos</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">peak_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="n">ref_pos</span><span class="p">))</span>
                <span class="c1"># Combnine DataFrame from target peaks</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">peak_line</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">generate_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pivot_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Make list of filenames without path and ext.</span>
        <span class="n">data_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">labels_from_filenames</span><span class="p">(</span><span class="n">data_labels</span><span class="p">,</span> <span class="n">pivot_string</span><span class="o">=</span><span class="n">pivot_string</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="n">numeric</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RamanGroup</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group of Raman spectra for comparison and multivariate analysis.</span>
<span class="sd">    Contains the spectra in form of a DataFrame in the *.data* attribute</span>
<span class="sd">    with spectra as rows and Raman shifts as columns. The column names are</span>
<span class="sd">    Raman shifts as *float*, while the index is the file basename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : list of *RamanChada* or *RamanSpectrum* objects</span>
<span class="sd">            &gt; Spectra to be included upon initialization.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G = RamanGroup( [s1, s2, s3] )</span>
<span class="sd">            </span>
<span class="sd">        interpolate : bool</span>
<span class="sd">            &gt; If True, Raman shifts are interpolated to increments of 1 1/cm.</span>
<span class="sd">            If False, all x axes will be interpolated to the x axis of the first spectrum added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">first_spectrum</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="n">first_spectrum</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">first_spectrum</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="n">first_spectrum</span><span class="o">.</span><span class="n">y_label</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spectrum_to_frame</span><span class="p">(</span><span class="n">first_spectrum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            
    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">use_new_x</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single spectrum.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectrum : *RamanChada* or *RamanSpectrum* object</span>
<span class="sd">            &gt; Spectrum to be added.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G.add_one(s4)</span>
<span class="sd">            </span>
<span class="sd">        use_new_x : bool</span>
<span class="sd">            &gt; If True, the existing x axes will be interpolated to the newly added spectrum.</span>
<span class="sd">            If False, the x axis will be interpolated on the existing x axes. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert added spectrum to DataFrame with x values as rows</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spectrum_to_frame</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Merge existing self.data with S while using the &#39;outer&#39; union with both sets of x values</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
        <span class="c1"># Interpolate missing values and reindex on original x axis. Fill NaNs with zeros.</span>
        <span class="k">if</span> <span class="n">use_new_x</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">index</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="s1">&#39;quadratic&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a list of spectra.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : list of *RamanChada* or *RamanSpectrum* objects</span>
<span class="sd">            &gt; Spectra to be added.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G.add( [s5, s6] )</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_one</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectra</span> <span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">set_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds targets for plottting prediction model training.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_dict : dict</span>
<span class="sd">            &gt; Targets to be added to the group as dict.</span>
<span class="sd">            Keys are arbitrary target names, while values must be lists</span>
<span class="sd">            or 1-dim arrays with a lenght matching the number of spectra in the *RamanGroup*,</span>
<span class="sd">            i.e. `len(target_dict) = len(G.data)`.</span>
<span class="sd">            Target values can be strings (for classification) or numbers (for regression).</span>
<span class="sd">            The targets are stored in *RamanGroup.targets*, a *DataFrame*.</span>
<span class="sd">            Note that multiple targets can be added.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">target_dict</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_of_spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a specified single spectrum from the *RamanGroup*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        no_of_spectrum : int</span>
<span class="sd">            &gt; Index of the spectrum to be extracted.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanChada</span>
<span class="sd">            &gt; Extracted spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">line_to_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">no_of_spectrum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of a *RamanGroup*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanGroup</span>
<span class="sd">            &gt; Exact copy of *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a single pre-processing step to a *RamanGroup*.</span>
<span class="sd">        Uses the function *ramanchada.models.process_DF*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            &gt; Name of *RamanChada* method to be applied.</span>
<span class="sd">            For details, refer to *ramanchada.RamanChada*.</span>
<span class="sd">            </span>
<span class="sd">        *args : str of number</span>
<span class="sd">            &gt; Non-keyword parameters for method</span>

<span class="sd">        **kwargs</span>
<span class="sd">            &gt; Keyword parameters for method   </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">process_DF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Common x axis of *RamanGroup* as 1D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Y values of *RamanGroup* as array with dimensions [n_spectra, n_channels]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> containing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> spectra.&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;targets&#39;</span><span class="p">):</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span><span class="si">}</span><span class="s1"> added&#39;</span>
        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-9</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">],</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots spectra of a *RamanGroup* in a single axis. </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : str</span>
<span class="sd">            &gt; Name of target to be used for hue. If given, spectra with a</span>
<span class="sd">            common target will be represented by their mean spectrum, with</span>
<span class="sd">            a spread corresponding to the standard deviation at each Raman shift.</span>
<span class="sd">            This is particularly useful if a large number of spectra are plotted.</span>
<span class="sd">            The default is None.</span>

<span class="sd">        xrange : list of double [x_min, x_max]</span>
<span class="sd">            &gt; x interval to be plotted. The default is [1e-9, 1e9] (all).</span>

<span class="sd">        legend : bool</span>
<span class="sd">            &gt; If True, a legend will be shown. The default is False. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plot_style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="c1">#target = &#39;times&#39;</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">DF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">))</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">DF</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ci</span><span class="o">=</span><span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="n">n_boot</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">RamanCalibration</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing a Raman x axis calibration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3500</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">poly_degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : DataFrame</span>
<span class="sd">            &gt; DataFrame with two columns, the first containing the x positions and the second containing the shifts at these positions.</span>
<span class="sd">            </span>
<span class="sd">        poly_degree : int, optional</span>
<span class="sd">            &gt; Degree of polynomial model fitted to the data points. The default is 3.</span>
<span class="sd">            </span>
<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            &gt; If True, values of the polynomial model which are outside of the data range used for calibration are interpolated.</span>
<span class="sd">            If False, all shifts outside the data range are set to the boundary values.</span>
<span class="sd">            The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># fit shift vector</span>
        <span class="c1"># If specified, use 1d linear interpolation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only apply shift within x limits of calibration data</span>
                <span class="c1"># Set shifts outside the limits to boundary values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">interpolation_within_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the calibration data points and the associated model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_x</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">RamanMTF</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing an MTF model in Fourier space. The reciprocal coordinate is 1/pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;Nyquist frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
        <span class="c1"># k + CTF come as 1024 px vectors.</span>


<span class="k">class</span> <span class="nc">RamanCTF</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing an MTF model in Fourier space. The reciprocal coordinate is 1/x units.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;spatial frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
        <span class="c1"># k + CTF come as 1024 px vectors.</span>


<span class="k">class</span> <span class="nc">MetaData</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing meta data as a dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
    <span class="c1"># Can be loaded or generated as dict, independently from data</span>
<span class="c1">#    - from_file</span>
<span class="c1">#    - clean</span>


<span class="k">def</span> <span class="nf">spectrum_to_frame</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a spectrum to a *DataFrame* with a single row.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrum : Spectrum, RamanSpectrum or RamanChada</span>
<span class="sd">        &gt; Spectrum to be converted</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame</span>
<span class="sd">        &gt; DataFrame with a single row.</span>
<span class="sd">        For details, see *ramanchada.classes.RamanGroup*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="s1">&#39;meta&#39;</span><span class="p">):</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="s1">&#39;intensity&#39;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">column_name</span><span class="p">:</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">})</span>
    <span class="n">D</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x</span>
    <span class="n">D</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span>
    <span class="n">D</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y_label&#39;</span><span class="p">:</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y_label</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span>

<span class="k">def</span> <span class="nf">spectrum_to_series</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a spectrum to a pandas *Series*.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrum : Spectrum, RamanSpectrum or RamanChada</span>
<span class="sd">        &gt; Spectrum to be converted</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.Series</span>
<span class="sd">        &gt; Series with Raman shifts as index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
    <span class="n">S</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x</span>
    <span class="n">S</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span>
    <span class="k">return</span> <span class="n">S</span>

<span class="k">def</span> <span class="nf">line_to_spectrum</span><span class="p">(</span><span class="n">DF</span><span class="p">,</span> <span class="n">no_line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the specified row of a *DataFrame* to a *Spectrum*.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    DF : DataFrame</span>
<span class="sd">        &gt; *pandas.DataFrame* structured as described in *ramanchada.classes.RamanGroup*</span>
<span class="sd">    </span>
<span class="sd">    no_line : int</span>
<span class="sd">        &gt; Row index to be converted </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ramanchada.classes.Spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">no_line</span><span class="p">]</span>
    <span class="n">S</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
    <span class="n">S</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">x_column_name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">y_column_name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">process_DF</span><span class="p">(</span><span class="n">DF</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a single pre-processing step to each row of a *DataFrame*.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : str</span>
<span class="sd">        &gt; Name of *RamanChada* method to be applied.</span>
<span class="sd">        For details, refer to *ramanchada.classes.RamanChada*.</span>
<span class="sd">        </span>
<span class="sd">    *args : str of number</span>
<span class="sd">        &gt; Non-keyword parameters for method</span>

<span class="sd">    **kwargs</span>
<span class="sd">        &gt; Keyword parameters for method   </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    *pandas.DataFrame*</span>
<span class="sd">        &gt; Processed *DataFrame*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DF</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">line_to_spectrum</span><span class="p">(</span><span class="n">DF</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">DF_proc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">DF_proc</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span>
    <span class="n">DF_proc</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">DF_proc</span>
</pre></div>

        </details>

            </section>
                <section id="Curve">
                                <div class="attr class">
        <a class="headerlink" href="#Curve">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Curve</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Curve</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic Data class with designated x and y columns. Can be spectra, distributions, chromatograms, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt;Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt;Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt;Name of the column holding the y data.  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># data is a pd.DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x_column_name</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y_column_name</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1"> points generated </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>\
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>\
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">info</span>
    <span class="nd">@specstyle</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the curve, i.e. the y data against x data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;snv&#39;</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize y data by subtracting a constant, followed by dividing by another constant.</span>
<span class="sd">        Both constants are calculated from the y data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Normalization method as described in *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;snv&#39;: standard normal variate - subtract mean, divide by standard deviation  </span>
<span class="sd">            - &#39;vector&#39;: vector normalization  - subtract 0, divide by vector norm   </span>
<span class="sd">            - &#39;minmax&#39;: min-max scaling - subtract minimun, divide by maximum  </span>
<span class="sd">            - &#39;area&#39;: integrated intensity scaling - subtract minimun, divide by mean  </span>
<span class="sd">            The default is &#39;snv&#39;.  </span>
<span class="sd">            </span>
<span class="sd">        x_min : double, optional</span>
<span class="sd">            &gt; Lower x boundary of interval where constants are determined from. The default is -1e9.</span>
<span class="sd">            </span>
<span class="sd">        x_max : double, optional. </span>
<span class="sd">            &gt; Upper x boundary of interval where constants are determined from. The default is 1e9.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;snv&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">],</span>
                   <span class="s1">&#39;vector&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">],</span>
                   <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">],</span>
                   <span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">]}</span>
        <span class="c1"># normalization is measured within specified interval</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">methods</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">0</span><span class="p">](</span><span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">/=</span> <span class="n">methods</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing / denoising of x data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Smoothing method. Can be one of the following:</span>

<span class="sd">        **- &#39;sg&#39;: Savitzky-Golay filter** - see scipy.signal.savgol_filter</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        window_length : int, optional</span>
<span class="sd">        &gt; Window Length for Savitzky-Golay filter. The default is 11.</span>
<span class="sd">        </span>
<span class="sd">        polyorder : int, optional</span>
<span class="sd">        &gt; Polynomial order for Savitzky-Golay filter. The default is 3.</span>

<span class="sd">        **- &#39;wiener&#39;: Wien filter** - see scipy.signal.wiener</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        mysize : int or array_like, optional</span>
<span class="sd">        &gt; A scalar or an N-length list giving the size of the Wiener filter window in each dimension. Elements of mysize should be odd. If mysize is a scalar, then this scalar is used as the size in each dimension.</span>

<span class="sd">        noise : float, optional</span>
<span class="sd">        &gt; The noise-power to use. If None, then noise is estimated as the average of the local variance of the input.</span>

<span class="sd">        **- &#39;median&#39;: median filter** - see scipy.signal.medfilt</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        kernel_size : array_like, optional</span>
<span class="sd">        &gt; A scalar or an N-length list giving the size of the median filter window in each dimension. Elements of kernel_size should be odd. If kernel_size is a scalar, then this scalar is used as the size in each dimension. Default size is 3 for each dimension.</span>

<span class="sd">        **- &#39;gauss&#39;: Gauss filter** - see scipy.ndimage.gaussian_filter1d</span>

<span class="sd">        sigma : scalar</span>
<span class="sd">        &gt; Standard deviation for Gaussian kernel</span>

<span class="sd">        **- &#39;lowess&#39;: Locally Weighted Scatterplot Smoothing (LOWESS)** - see statsmodels.nonparametric.smoothers_lowess.lowess</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        span : float</span>
<span class="sd">        &gt; Width of interval (in channels) to use for estimating each y-value.</span>

<span class="sd">        **- &#39;boxcar&#39;: filter by rectangular window or Dirichlet window**</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        box_pts : int</span>
<span class="sd">        &gt; Number of points in the output window. If zero or less, an empty array is returned.</span>

<span class="sd">        The default is &#39;sg&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;window_length&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;polyorder&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">smooth_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">x_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Crop data on x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_min : double</span>
<span class="sd">            &gt; Lower x boundary of interval in x units</span>
<span class="sd">            </span>
<span class="sd">        x_max : double</span>
<span class="sd">            &gt; Upper x boundary of interval in x units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Basic Data class with designated x and y columns. Can be spectra, distributions, chromatograms, ...</p>
</div>


                            <div id="Curve.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Curve.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Curve</span><span class="signature">(data, x_column_name, y_column_name)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt;Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt;Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt;Name of the column holding the y data.  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># data is a pd.DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x_column_name</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y_column_name</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>data : pandas DataFrame</p>

<blockquote>
  <p>Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</p>
</blockquote>

<p>x_column_name : str</p>

<blockquote>
  <p>Name of the column holding the x data.</p>
</blockquote>

<p>y_column_name : str</p>

<blockquote>
  <p>Name of the column holding the y data.  </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Curve.plot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Curve.plot">#&nbsp;&nbsp</a>

                <div class="decorator">@specstyle</div>

            <span class="def">def</span>
            <span class="name">plot</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@specstyle</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the curve, i.e. the y data against x data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot the curve, i.e. the y data against x data.</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Curve.normalize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Curve.normalize">#&nbsp;&nbsp</a>

                <div class="decorator">@change_y</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">normalize</span><span class="signature">(self, method=&#39;snv&#39;, x_min=-1000000000.0, x_max=1000000000.0)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;snv&#39;</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize y data by subtracting a constant, followed by dividing by another constant.</span>
<span class="sd">        Both constants are calculated from the y data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Normalization method as described in *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;snv&#39;: standard normal variate - subtract mean, divide by standard deviation  </span>
<span class="sd">            - &#39;vector&#39;: vector normalization  - subtract 0, divide by vector norm   </span>
<span class="sd">            - &#39;minmax&#39;: min-max scaling - subtract minimun, divide by maximum  </span>
<span class="sd">            - &#39;area&#39;: integrated intensity scaling - subtract minimun, divide by mean  </span>
<span class="sd">            The default is &#39;snv&#39;.  </span>
<span class="sd">            </span>
<span class="sd">        x_min : double, optional</span>
<span class="sd">            &gt; Lower x boundary of interval where constants are determined from. The default is -1e9.</span>
<span class="sd">            </span>
<span class="sd">        x_max : double, optional. </span>
<span class="sd">            &gt; Upper x boundary of interval where constants are determined from. The default is 1e9.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;snv&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">],</span>
                   <span class="s1">&#39;vector&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">],</span>
                   <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">],</span>
                   <span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">]}</span>
        <span class="c1"># normalization is measured within specified interval</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">methods</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">0</span><span class="p">](</span><span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">/=</span> <span class="n">methods</span><span class="p">[</span><span class="n">method</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Normalize y data by subtracting a constant, followed by dividing by another constant.
Both constants are calculated from the y data.</p>

<h2 id="parameters">Parameters</h2>

<p>method : str, optional</p>

<blockquote>
  <p>Normalization method as described in <em>Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.</em> <br />
      - 'snv': standard normal variate - subtract mean, divide by standard deviation <br />
      - 'vector': vector normalization  - subtract 0, divide by vector norm <br />
      - 'minmax': min-max scaling - subtract minimun, divide by maximum <br />
      - 'area': integrated intensity scaling - subtract minimun, divide by mean <br />
      The default is 'snv'.  </p>
</blockquote>

<p>x_min : double, optional</p>

<blockquote>
  <p>Lower x boundary of interval where constants are determined from. The default is -1e9.</p>
</blockquote>

<p>x_max : double, optional. </p>

<blockquote>
  <p>Upper x boundary of interval where constants are determined from. The default is 1e9.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Curve.smooth" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Curve.smooth">#&nbsp;&nbsp</a>

                <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">smooth</span><span class="signature">(self, method=&#39;sg&#39;, *args, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smoothing / denoising of x data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Smoothing method. Can be one of the following:</span>

<span class="sd">        **- &#39;sg&#39;: Savitzky-Golay filter** - see scipy.signal.savgol_filter</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        window_length : int, optional</span>
<span class="sd">        &gt; Window Length for Savitzky-Golay filter. The default is 11.</span>
<span class="sd">        </span>
<span class="sd">        polyorder : int, optional</span>
<span class="sd">        &gt; Polynomial order for Savitzky-Golay filter. The default is 3.</span>

<span class="sd">        **- &#39;wiener&#39;: Wien filter** - see scipy.signal.wiener</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        mysize : int or array_like, optional</span>
<span class="sd">        &gt; A scalar or an N-length list giving the size of the Wiener filter window in each dimension. Elements of mysize should be odd. If mysize is a scalar, then this scalar is used as the size in each dimension.</span>

<span class="sd">        noise : float, optional</span>
<span class="sd">        &gt; The noise-power to use. If None, then noise is estimated as the average of the local variance of the input.</span>

<span class="sd">        **- &#39;median&#39;: median filter** - see scipy.signal.medfilt</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        kernel_size : array_like, optional</span>
<span class="sd">        &gt; A scalar or an N-length list giving the size of the median filter window in each dimension. Elements of kernel_size should be odd. If kernel_size is a scalar, then this scalar is used as the size in each dimension. Default size is 3 for each dimension.</span>

<span class="sd">        **- &#39;gauss&#39;: Gauss filter** - see scipy.ndimage.gaussian_filter1d</span>

<span class="sd">        sigma : scalar</span>
<span class="sd">        &gt; Standard deviation for Gaussian kernel</span>

<span class="sd">        **- &#39;lowess&#39;: Locally Weighted Scatterplot Smoothing (LOWESS)** - see statsmodels.nonparametric.smoothers_lowess.lowess</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        span : float</span>
<span class="sd">        &gt; Width of interval (in channels) to use for estimating each y-value.</span>

<span class="sd">        **- &#39;boxcar&#39;: filter by rectangular window or Dirichlet window**</span>
<span class="sd">        </span>
<span class="sd">        **kwargs</span>

<span class="sd">        box_pts : int</span>
<span class="sd">        &gt; Number of points in the output window. If zero or less, an empty array is returned.</span>

<span class="sd">        The default is &#39;sg&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;window_length&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;polyorder&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">smooth_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Smoothing / denoising of x data.</p>

<h2 id="parameters">Parameters</h2>

<p>method : str, optional</p>

<blockquote>
  <p>Smoothing method. Can be one of the following:</p>
</blockquote>

<p><strong>- 'sg': Savitzky-Golay filter</strong> - see scipy.signal.savgol_filter</p>

<p>**kwargs</p>

<p>window_length : int, optional</p>

<blockquote>
  <p>Window Length for Savitzky-Golay filter. The default is 11.</p>
</blockquote>

<p>polyorder : int, optional</p>

<blockquote>
  <p>Polynomial order for Savitzky-Golay filter. The default is 3.</p>
</blockquote>

<p><strong>- 'wiener': Wien filter</strong> - see scipy.signal.wiener</p>

<p>**kwargs</p>

<p>mysize : int or array_like, optional</p>

<blockquote>
  <p>A scalar or an N-length list giving the size of the Wiener filter window in each dimension. Elements of mysize should be odd. If mysize is a scalar, then this scalar is used as the size in each dimension.</p>
</blockquote>

<p>noise : float, optional</p>

<blockquote>
  <p>The noise-power to use. If None, then noise is estimated as the average of the local variance of the input.</p>
</blockquote>

<p><strong>- 'median': median filter</strong> - see scipy.signal.medfilt</p>

<p>**kwargs</p>

<p>kernel_size : array_like, optional</p>

<blockquote>
  <p>A scalar or an N-length list giving the size of the median filter window in each dimension. Elements of kernel_size should be odd. If kernel_size is a scalar, then this scalar is used as the size in each dimension. Default size is 3 for each dimension.</p>
</blockquote>

<p><strong>- 'gauss': Gauss filter</strong> - see scipy.ndimage.gaussian_filter1d</p>

<p>sigma : scalar</p>

<blockquote>
  <p>Standard deviation for Gaussian kernel</p>
</blockquote>

<p><strong>- 'lowess': Locally Weighted Scatterplot Smoothing (LOWESS)</strong> - see statsmodels.nonparametric.smoothers_lowess.lowess</p>

<p>**kwargs</p>

<p>span : float</p>

<blockquote>
  <p>Width of interval (in channels) to use for estimating each y-value.</p>
</blockquote>

<p><strong>- 'boxcar': filter by rectangular window or Dirichlet window</strong></p>

<p>**kwargs</p>

<p>box_pts : int</p>

<blockquote>
  <p>Number of points in the output window. If zero or less, an empty array is returned.</p>
</blockquote>

<p>The default is 'sg'.</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Curve.x_crop" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Curve.x_crop">#&nbsp;&nbsp</a>

                <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">x_crop</span><span class="signature">(self, x_min, x_max)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">x_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Crop data on x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_min : double</span>
<span class="sd">            &gt; Lower x boundary of interval in x units</span>
<span class="sd">            </span>
<span class="sd">        x_max : double</span>
<span class="sd">            &gt; Upper x boundary of interval in x units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Crop data on x axis.</p>

<h2 id="parameters">Parameters</h2>

<p>x_min : double</p>

<blockquote>
  <p>Lower x boundary of interval in x units</p>
</blockquote>

<p>x_max : double</p>

<blockquote>
  <p>Upper x boundary of interval in x units.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                </section>
                <section id="Spectrum">
                                <div class="attr class">
        <a class="headerlink" href="#Spectrum">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Spectrum</span><wbr>(<span class="base"><a href="#Curve">Curve</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Spectrum</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A curve with peaks that can be located and analyzed.</span>
<span class="sd">    Inherits from Curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;spectral index&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;intensity [a.u.]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt; Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the y data.</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; Label for x data. The default is &#39;spectral index&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : TYPE, optional</span>
<span class="sd">            &gt; Label for y data The default is &#39;intensity [a.u.]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">y_label</span>
        
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flips y axis by inversion followed by minimum subtraction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">cwt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fitmethod</span> <span class="o">=</span> <span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cwt_width</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
              <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;prominence&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automated detection and analysis of peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_min : double, optional</span>
<span class="sd">            &gt; Lower x boundary of search interval in x units. The default is -1e9.</span>
<span class="sd">            </span>
<span class="sd">        x_max : double, optional</span>
<span class="sd">            &gt; Upper x boundary of search interval in x units. The default is 1e9.</span>
<span class="sd">            </span>
<span class="sd">        fit : bool, optional</span>
<span class="sd">            &gt; True if peak parameters should be determined by fitting an analytical model. The default is True.</span>
<span class="sd">            </span>
<span class="sd">        fitmethod : str, optional</span>
<span class="sd">            &gt; Model to fit to each peak.   </span>
<span class="sd">            - &#39;par&#39;: parabola  </span>
<span class="sd">            - &#39;voigt&#39;: Voigt distribution  </span>
<span class="sd">            - &#39;vg&#39;: Sum of independent Gauss + Voigt model  </span>
<span class="sd">            The default is &#39;voigt&#39;.</span>
<span class="sd">            </span>
<span class="sd">        interval_width : double, optional</span>
<span class="sd">            &gt; The interval width, in FWHMs, on which each peak is fitted. The default is 2.</span>
<span class="sd">            </span>
<span class="sd">        sort_by : str, optional</span>
<span class="sd">            &gt; The column after which peaks are sorted in the .bands attribute. The default is &#39;prominence&#39;.</span>
<span class="sd">            </span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            &gt; True if fits should be plotted with the data for each peak. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cwt</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="n">find_spectrum_peaks_cwt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">cwt_width</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;intensity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="n">find_spectrum_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="n">sort_by</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
            <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="n">fit_spectrum_peaks_pos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="n">fitmethod</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="n">interval_width</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted FWHM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas</span>
    <span class="nd">@specstyle</span>
    <span class="nd">@mark_peaks</span>
    <span class="k">def</span> <span class="nf">show_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bands&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No bands located yet. Use *.peaks()* first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">style</span>
    <span class="k">def</span> <span class="nf">fit_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a flourescent background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Model fitting method as described in  </span>
<span class="sd">            *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;als&#39;: Asymmetric least squares.  </span>
<span class="sd">            After *He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.*  </span>
<span class="sd">            - &#39;snip&#39;: statistics-sensitive non-linear iterative peak clipping.  </span>
<span class="sd">            After *Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.*    </span>
<span class="sd">            The default is &#39;als&#39;.</span>
<span class="sd">            </span>
<span class="sd">        lam : double, optional</span>
<span class="sd">            &gt; lambda parameter for ALS. The default is 1e5.</span>
<span class="sd">            </span>
<span class="sd">        p : double, optional</span>
<span class="sd">            &gt; p parameter for ALS. The default is 0.001.</span>
<span class="sd">            </span>
<span class="sd">        niter : int, optional</span>
<span class="sd">            &gt; Number of iterations. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">        smooth : int, optional</span>
<span class="sd">            &gt; Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">remove_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits and removes a flourescent background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Model fitting method as described in  </span>
<span class="sd">            *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;als&#39;: Asymmetric least squares.  </span>
<span class="sd">            After *He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.*  </span>
<span class="sd">            - &#39;snip&#39;: statistics-sensitive non-linear iterative peak clipping.  </span>
<span class="sd">            After *Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.*    </span>
<span class="sd">            The default is &#39;als&#39;.</span>
<span class="sd">            </span>
<span class="sd">        lam : double, optional</span>
<span class="sd">            &gt; lambda parameter for ALS. The default is 1e5.</span>
<span class="sd">            </span>
<span class="sd">        p : double, optional</span>
<span class="sd">            &gt; p parameter for ALS. The default is 0.001.</span>
<span class="sd">            </span>
<span class="sd">        niter : int, optional</span>
<span class="sd">            &gt; Number of iterations. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">        smooth : int, optional</span>
<span class="sd">            &gt; Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_baseline</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span>
            
    <span class="nd">@change_x</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">interpolate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate spectrum onto the x axis of a reference spectrum. If no reference is given, the x axis is interpolated to an increment of 1.0 units (usually rel 1/cm).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_spectrum : Spectrum, optional</span>
<span class="sd">            &gt; Reference spectrum. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no reference is given, just sample to one wavenumber</span>
        <span class="k">if</span> <span class="n">reference_spectrum</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">reference_spectrum</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># reference_spectrum is a Spectrum</span>
        <span class="n">f_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f_inter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">hqi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Hit Quality Index after *Rodriguez, J. D., Westenberger, B. J., Buhse, L. F., &amp; Kauffman, J. F. (2011b). Standardization of Raman spectra for transfer of spectral libraries across different instruments. Analyst, 136(20), 4232â€“4240. https://doi.org/10.1039/c1an15636e*  </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt; reference_spectrum : Spectrum</span>
<span class="sd">            Reference Spectrum with which HQI is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        double</span>
<span class="sd">            &gt; Hit Quality Index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy to avoid changing data upon interpolate_x</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="n">reference_spectrum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hqi</span><span class="p">(</span><span class="n">self_copy</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
            <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span>
            <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A curve with peaks that can be located and analyzed.
Inherits from Curve.</p>
</div>


                            <div id="Spectrum.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Spectrum</span><span class="signature">(
    data,
    x_column_name,
    y_column_name,
    label=None,
    x_label=&#39;spectral index&#39;,
    y_label=&#39;intensity [a.u.]&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;spectral index&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;intensity [a.u.]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt; Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the y data.</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; Label for x data. The default is &#39;spectral index&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : TYPE, optional</span>
<span class="sd">            &gt; Label for y data The default is &#39;intensity [a.u.]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">y_label</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>data : pandas DataFrame</p>

<blockquote>
  <p>Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</p>
</blockquote>

<p>x_column_name : str</p>

<blockquote>
  <p>Name of the column holding the x data.</p>
</blockquote>

<p>y_column_name : str</p>

<blockquote>
  <p>Name of the column holding the y data.</p>
</blockquote>

<p>x_label : str, optional</p>

<blockquote>
  <p>Label for x data. The default is 'spectral index'.</p>
</blockquote>

<p>y_label : TYPE, optional</p>

<blockquote>
  <p>Label for y data The default is 'intensity [a.u.]'.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Spectrum.invert" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.invert">#&nbsp;&nbsp</a>

                <div class="decorator">@change_y</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">invert</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flips y axis by inversion followed by minimum subtraction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Flips y axis by inversion followed by minimum subtraction.</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Spectrum.peaks" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.peaks">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">peaks</span><span class="signature">(
    self,
    prominence=0.05,
    x_min=-1000000000.0,
    x_max=1000000000.0,
    cwt=False,
    fit=True,
    fitmethod=&#39;voigt&#39;,
    interval_width=2,
    cwt_width=20,
    sort_by=&#39;prominence&#39;,
    show=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">cwt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fitmethod</span> <span class="o">=</span> <span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cwt_width</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
              <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;prominence&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automated detection and analysis of peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_min : double, optional</span>
<span class="sd">            &gt; Lower x boundary of search interval in x units. The default is -1e9.</span>
<span class="sd">            </span>
<span class="sd">        x_max : double, optional</span>
<span class="sd">            &gt; Upper x boundary of search interval in x units. The default is 1e9.</span>
<span class="sd">            </span>
<span class="sd">        fit : bool, optional</span>
<span class="sd">            &gt; True if peak parameters should be determined by fitting an analytical model. The default is True.</span>
<span class="sd">            </span>
<span class="sd">        fitmethod : str, optional</span>
<span class="sd">            &gt; Model to fit to each peak.   </span>
<span class="sd">            - &#39;par&#39;: parabola  </span>
<span class="sd">            - &#39;voigt&#39;: Voigt distribution  </span>
<span class="sd">            - &#39;vg&#39;: Sum of independent Gauss + Voigt model  </span>
<span class="sd">            The default is &#39;voigt&#39;.</span>
<span class="sd">            </span>
<span class="sd">        interval_width : double, optional</span>
<span class="sd">            &gt; The interval width, in FWHMs, on which each peak is fitted. The default is 2.</span>
<span class="sd">            </span>
<span class="sd">        sort_by : str, optional</span>
<span class="sd">            &gt; The column after which peaks are sorted in the .bands attribute. The default is &#39;prominence&#39;.</span>
<span class="sd">            </span>
<span class="sd">        show : bool, optional</span>
<span class="sd">            &gt; True if fits should be plotted with the data for each peak. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cwt</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="n">find_spectrum_peaks_cwt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">cwt_width</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;intensity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="n">find_spectrum_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="n">sort_by</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
            <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="n">fit_spectrum_peaks_pos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="n">fitmethod</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="n">interval_width</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted FWHM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s1">&#39; fitted area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas</span>
</pre></div>

        </details>

            <div class="docstring"><p>Automated detection and analysis of peaks.</p>

<h2 id="parameters">Parameters</h2>

<p>x_min : double, optional</p>

<blockquote>
  <p>Lower x boundary of search interval in x units. The default is -1e9.</p>
</blockquote>

<p>x_max : double, optional</p>

<blockquote>
  <p>Upper x boundary of search interval in x units. The default is 1e9.</p>
</blockquote>

<p>fit : bool, optional</p>

<blockquote>
  <p>True if peak parameters should be determined by fitting an analytical model. The default is True.</p>
</blockquote>

<p>fitmethod : str, optional</p>

<blockquote>
  <p>Model to fit to each peak. <br />
      - 'par': parabola <br />
      - 'voigt': Voigt distribution <br />
      - 'vg': Sum of independent Gauss + Voigt model <br />
      The default is 'voigt'.</p>
</blockquote>

<p>interval_width : double, optional</p>

<blockquote>
  <p>The interval width, in FWHMs, on which each peak is fitted. The default is 2.</p>
</blockquote>

<p>sort_by : str, optional</p>

<blockquote>
  <p>The column after which peaks are sorted in the .bands attribute. The default is 'prominence'.</p>
</blockquote>

<p>show : bool, optional</p>

<blockquote>
  <p>True if fits should be plotted with the data for each peak. The default is False.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Spectrum.show_bands" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.show_bands">#&nbsp;&nbsp</a>

                <div class="decorator">@specstyle</div>
        <div class="decorator">@mark_peaks</div>

            <span class="def">def</span>
            <span class="name">show_bands</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@specstyle</span>
    <span class="nd">@mark_peaks</span>
    <span class="k">def</span> <span class="nf">show_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bands&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No bands located yet. Use *.peaks()* first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">style</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Spectrum.fit_baseline" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.fit_baseline">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit_baseline</span><span class="signature">(self, method=&#39;als&#39;, lam=100000.0, p=0.001, niter=100, smooth=7)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a flourescent background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Model fitting method as described in  </span>
<span class="sd">            *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;als&#39;: Asymmetric least squares.  </span>
<span class="sd">            After *He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.*  </span>
<span class="sd">            - &#39;snip&#39;: statistics-sensitive non-linear iterative peak clipping.  </span>
<span class="sd">            After *Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.*    </span>
<span class="sd">            The default is &#39;als&#39;.</span>
<span class="sd">            </span>
<span class="sd">        lam : double, optional</span>
<span class="sd">            &gt; lambda parameter for ALS. The default is 1e5.</span>
<span class="sd">            </span>
<span class="sd">        p : double, optional</span>
<span class="sd">            &gt; p parameter for ALS. The default is 0.001.</span>
<span class="sd">            </span>
<span class="sd">        niter : int, optional</span>
<span class="sd">            &gt; Number of iterations. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">        smooth : int, optional</span>
<span class="sd">            &gt; Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fits a flourescent background model.</p>

<h2 id="parameters">Parameters</h2>

<p>method : str, optional</p>

<blockquote>
  <p>Model fitting method as described in <br />
      <em>Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.</em> <br />
      - 'als': Asymmetric least squares. <br />
      After <em>He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.</em> <br />
      - 'snip': statistics-sensitive non-linear iterative peak clipping. <br />
      After <em>Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.</em> <br />
      The default is 'als'.</p>
</blockquote>

<p>lam : double, optional</p>

<blockquote>
  <p>lambda parameter for ALS. The default is 1e5.</p>
</blockquote>

<p>p : double, optional</p>

<blockquote>
  <p>p parameter for ALS. The default is 0.001.</p>
</blockquote>

<p>niter : int, optional</p>

<blockquote>
  <p>Number of iterations. The default is 100.</p>
</blockquote>

<p>smooth : int, optional</p>

<blockquote>
  <p>Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Spectrum.remove_baseline" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.remove_baseline">#&nbsp;&nbsp</a>

                <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">remove_baseline</span><span class="signature">(self, method=&#39;als&#39;, lam=100000.0, p=0.001, niter=100, smooth=7)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">remove_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits and removes a flourescent background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &gt; Model fitting method as described in  </span>
<span class="sd">            *Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.*  </span>
<span class="sd">            - &#39;als&#39;: Asymmetric least squares.  </span>
<span class="sd">            After *He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.*  </span>
<span class="sd">            - &#39;snip&#39;: statistics-sensitive non-linear iterative peak clipping.  </span>
<span class="sd">            After *Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.*    </span>
<span class="sd">            The default is &#39;als&#39;.</span>
<span class="sd">            </span>
<span class="sd">        lam : double, optional</span>
<span class="sd">            &gt; lambda parameter for ALS. The default is 1e5.</span>
<span class="sd">            </span>
<span class="sd">        p : double, optional</span>
<span class="sd">            &gt; p parameter for ALS. The default is 0.001.</span>
<span class="sd">            </span>
<span class="sd">        niter : int, optional</span>
<span class="sd">            &gt; Number of iterations. The default is 100.</span>
<span class="sd">            </span>
<span class="sd">        smooth : int, optional</span>
<span class="sd">            &gt; Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_baseline</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;als&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fits and removes a flourescent background model.</p>

<h2 id="parameters">Parameters</h2>

<p>method : str, optional</p>

<blockquote>
  <p>Model fitting method as described in <br />
      <em>Ryabchykov, O., Guo, S., &amp; Bocklitz, T. (2019). Analyzing Raman spectroscopic data. Physical Sciences Reviews, 4(2), 1â€“16. https://doi.org/10.1515/psr-2017-0043.</em> <br />
      - 'als': Asymmetric least squares. <br />
      After <em>He, S., Zhang, W., Liu, L., Huang, Y., He, J., Xie, W., â€¦ P. W.-A., &amp; 2014,  undefined. (n.d.). Baseline correction for Raman spectra using an improved asymmetric least squares method. Pubs.Rsc.Org.</em> <br />
      - 'snip': statistics-sensitive non-linear iterative peak clipping. <br />
      After <em>Caccia, M., Ebolese, A., Maspero, M., Santoro, R., Tecnologia, A., Locatelli, M., Pieracci, M., Tintori, C., &amp; Caen, S. A. (n.d.). Background removal procedure based on the SNIP algorithm for Î³ âˆ’ ray spectroscopy with the CAEN Educational Kit. CAEN Tools for Discovery Educational Note ED3163, 1â€“4.</em> <br />
      The default is 'als'.</p>
</blockquote>

<p>lam : double, optional</p>

<blockquote>
  <p>lambda parameter for ALS. The default is 1e5.</p>
</blockquote>

<p>p : double, optional</p>

<blockquote>
  <p>p parameter for ALS. The default is 0.001.</p>
</blockquote>

<p>niter : int, optional</p>

<blockquote>
  <p>Number of iterations. The default is 100.</p>
</blockquote>

<p>smooth : int, optional</p>

<blockquote>
  <p>Kernel length for Wien filtering prior to ALS baseline fitting. The default is 7.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Spectrum.interpolate_x" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.interpolate_x">#&nbsp;&nbsp</a>

                <div class="decorator">@change_x</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">interpolate_x</span><span class="signature">(self, reference_spectrum=[])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_x</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">interpolate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate spectrum onto the x axis of a reference spectrum. If no reference is given, the x axis is interpolated to an increment of 1.0 units (usually rel 1/cm).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_spectrum : Spectrum, optional</span>
<span class="sd">            &gt; Reference spectrum. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no reference is given, just sample to one wavenumber</span>
        <span class="k">if</span> <span class="n">reference_spectrum</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">reference_spectrum</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># reference_spectrum is a Spectrum</span>
        <span class="n">f_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f_inter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Interpolate spectrum onto the x axis of a reference spectrum. If no reference is given, the x axis is interpolated to an increment of 1.0 units (usually rel 1/cm).</p>

<h2 id="parameters">Parameters</h2>

<p>reference_spectrum : Spectrum, optional</p>

<blockquote>
  <p>Reference spectrum. The default is None.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="Spectrum.hqi" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.hqi">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">hqi</span><span class="signature">(self, reference_spectrum)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">hqi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Hit Quality Index after *Rodriguez, J. D., Westenberger, B. J., Buhse, L. F., &amp; Kauffman, J. F. (2011b). Standardization of Raman spectra for transfer of spectral libraries across different instruments. Analyst, 136(20), 4232â€“4240. https://doi.org/10.1039/c1an15636e*  </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt; reference_spectrum : Spectrum</span>
<span class="sd">            Reference Spectrum with which HQI is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        double</span>
<span class="sd">            &gt; Hit Quality Index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy to avoid changing data upon interpolate_x</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="n">reference_spectrum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hqi</span><span class="p">(</span><span class="n">self_copy</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">reference_spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Calculates the Hit Quality Index after <em>Rodriguez, J. D., Westenberger, B. J., Buhse, L. F., &amp; Kauffman, J. F. (2011b). Standardization of Raman spectra for transfer of spectral libraries across different instruments. Analyst, 136(20), 4232â€“4240. https://doi.org/10.1039/c1an15636e</em>  </p>

<h2 id="parameters">Parameters</h2>

<blockquote>
  <p>reference_spectrum : Spectrum
      Reference Spectrum with which HQI is calculated.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>double</p>

<blockquote>
  <p>Hit Quality Index</p>
</blockquote>
</div>


                            </div>
                            <div id="Spectrum.math" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Spectrum.math">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">math</span><span class="signature">(self, spectrum, operator=&#39;+&#39;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
            <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span>
            <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Curve">Curve</a></dt>
                                <dd id="Spectrum.plot" class="function"><a href="#Curve.plot">plot</a></dd>
                <dd id="Spectrum.normalize" class="function"><a href="#Curve.normalize">normalize</a></dd>
                <dd id="Spectrum.smooth" class="function"><a href="#Curve.smooth">smooth</a></dd>
                <dd id="Spectrum.x_crop" class="function"><a href="#Curve.x_crop">x_crop</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RamanSpectrum">
                                <div class="attr class">
        <a class="headerlink" href="#RamanSpectrum">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RamanSpectrum</span><wbr>(<span class="base"><a href="#Spectrum">Spectrum</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RamanSpectrum</span><span class="p">(</span><span class="n">Spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for a Raman Spectrum, which can have metadata and can be calibrated.</span>
<span class="sd">    Inherits from *Spectrum*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">,</span>
                 <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;Raman Shift [rel 1/cm]&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;intensity [a.u.]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt; Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the y data.</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; Label for x data. The default is &#39;spectral index&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : TYPE, optional</span>
<span class="sd">            &gt; Label for y data The default is &#39;intensity [a.u.]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">y_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">add_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds metadata to a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_dict : dict</span>
<span class="sd">            &gt; Python dictionary, containing pairs of key: value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meta_dict</span><span class="p">)</span>
    <span class="nd">@change_x</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration : RamanCalibration</span>
<span class="sd">            &gt; Calibration object for the x  axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate Raman shift corrections</span>
        <span class="n">x_shifts</span> <span class="o">=</span> <span class="n">calibration</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Substitute with new x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x_shifts</span>
        <span class="c1"># Make sure x values remain sorted</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">make_x_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span> <span class="o">=</span> <span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">peak_pos</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an x axis calibration, either to a RamanSpectrum or a list of exact reference peak positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum or list</span>
<span class="sd">            &gt; Reference for calibration.</span>
<span class="sd">            If RamanSpectrum, the reference must be a spectrum recorded using the same sample, and calibrated.</span>
<span class="sd">            If list, the reference must be a list of exact peak positions.</span>
<span class="sd">            </span>
<span class="sd">        fitmethod : str, optional</span>
<span class="sd">            &gt; Model to fit to each peak of Target and Reference  </span>
<span class="sd">            - &#39;par&#39;: parabola  </span>
<span class="sd">            - &#39;voigt&#39;: Voigt distribution  </span>
<span class="sd">            - &#39;vg&#39;: Sum of independent Gauss + Voigt model  </span>
<span class="sd">            The default is &#39;voigt&#39;.</span>

<span class="sd">        peak_pos : list, optional</span>
<span class="sd">            &gt; Only if reference is a RamanSpectrum: peak positions that should be fit and included in the calibration.</span>
<span class="sd">            The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCalibration</span>
<span class="sd">            &gt; Calibration object containing the relative shifts as well as a polynomial interpolation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Returns a RamanCalibration</span>
        <span class="c1"># If a Raman spectrum is given as refernece</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RamanSpectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;RamanChada&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">raman_x_calibration_from_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">peak_pos</span><span class="o">=</span><span class="n">peak_pos</span><span class="p">)</span>
        <span class="c1"># If a list of peak positions is given</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">raman_x_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">calibrate_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the y axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration : RamanCalibration</span>
<span class="sd">            &gt; Calibration object for the y  axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate Raman gain corrections</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">calibration</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">gain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calibration not in data range!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Apply gain correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">gain</span>
    <span class="k">def</span> <span class="nf">make_y_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an y axis calibration to a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum</span>
<span class="sd">            &gt; The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</span>
<span class="sd">            </span>
<span class="sd">        x_min : double</span>
<span class="sd">            &gt; Lower x boundary of calibration interval in x units</span>
<span class="sd">            </span>
<span class="sd">        x_max : double</span>
<span class="sd">            &gt; Upper x boundary of calibration interval in x units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCalibration</span>
<span class="sd">            &gt; Calibration object containing the relative gain as well as a polynomial interpolation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">raman_y_calibration_from_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">x_max</span><span class="p">)</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">deconvolve_MTF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mtf</span><span class="p">,</span> <span class="n">gauss_filter_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolves an MTF from a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mtf : RamanMTF</span>
<span class="sd">            &gt; MTF object containing the MTF model in Fourier space.</span>
<span class="sd">            </span>
<span class="sd">        gauss_filter_sigma : double, optional</span>
<span class="sd">            &gt; Sigma of a Gauss filter applied after deconvolution to reduce excessive noise. The default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">deconvolve_mtf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">mtf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gauss_filter_sigma</span><span class="o">=</span><span class="n">gauss_filter_sigma</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">make_res_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the resolution (peak broadening) to that of a reference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum</span>
<span class="sd">            &gt; The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCTF</span>
<span class="sd">            &gt; Object containing the model of ther relative point spread function in Fourier space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use copies to not mess with data here</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">tar</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># crop ref to intersection</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">tar</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()])</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">tar</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">x_crop</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="c1"># interpolate both to common x with delta = 1/cm</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="c1"># normalize</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
        <span class="c1"># calc rel. CTF</span>
        <span class="n">rel_k</span><span class="p">,</span> <span class="n">rel_ctf</span> <span class="o">=</span> <span class="n">relative_ctf</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tar</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ctf_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">ctf_data</span><span class="p">[</span><span class="s1">&#39;spatial frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_k</span>
        <span class="n">ctf_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_ctf</span>
        <span class="k">return</span> <span class="n">RamanCTF</span><span class="p">(</span><span class="n">ctf_data</span><span class="p">)</span>
    <span class="nd">@change_x</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">set_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a relative CTF to a RamanSpectrum</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rel_ctf : RamanCTF</span>
<span class="sd">            &gt; Object containing the model of ther relative point spread function in Fourier space.</span>
<span class="sd">            When applied, the resolution is approximated to that of the reference instrument with which the CTF was calibrated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x values must be equally spaced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">apply_relative_ctf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a model for cosmic rays (x rays) to the y data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xrays</span> <span class="o">=</span> <span class="n">xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">remove_xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes cosmic rays by subtracting the model stored in .xrays (if it exists).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xrays&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xrays</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">get_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximates the signal-to-noise ratio of a Raman spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : double</span>
<span class="sd">            &gt; Approximation for SNR.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">snr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Class for a Raman Spectrum, which can have metadata and can be calibrated.
Inherits from <em>Spectrum</em>.</p>
</div>


                            <div id="RamanSpectrum.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RamanSpectrum</span><span class="signature">(
    data,
    x_column_name,
    y_column_name,
    x_label=&#39;Raman Shift [rel 1/cm]&#39;,
    y_label=&#39;intensity [a.u.]&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">,</span>
                 <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;Raman Shift [rel 1/cm]&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;intensity [a.u.]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : pandas DataFrame</span>
<span class="sd">            &gt; Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</span>
<span class="sd">            </span>
<span class="sd">        x_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the x data.</span>
<span class="sd">            </span>
<span class="sd">        y_column_name : str</span>
<span class="sd">            &gt; Name of the column holding the y data.</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; Label for x data. The default is &#39;spectral index&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : TYPE, optional</span>
<span class="sd">            &gt; Label for y data The default is &#39;intensity [a.u.]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_column_name</span><span class="p">,</span> <span class="n">y_column_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">y_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>data : pandas DataFrame</p>

<blockquote>
  <p>Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</p>
</blockquote>

<p>x_column_name : str</p>

<blockquote>
  <p>Name of the column holding the x data.</p>
</blockquote>

<p>y_column_name : str</p>

<blockquote>
  <p>Name of the column holding the y data.</p>
</blockquote>

<p>x_label : str, optional</p>

<blockquote>
  <p>Label for x data. The default is 'spectral index'.</p>
</blockquote>

<p>y_label : TYPE, optional</p>

<blockquote>
  <p>Label for y data The default is 'intensity [a.u.]'.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.add_metadata" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.add_metadata">#&nbsp;&nbsp</a>

                <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">add_metadata</span><span class="signature">(self, meta_dict)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">add_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds metadata to a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_dict : dict</span>
<span class="sd">            &gt; Python dictionary, containing pairs of key: value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meta_dict</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds metadata to a RamanSpectrum.</p>

<h2 id="parameters">Parameters</h2>

<p>meta_dict : dict</p>

<blockquote>
  <p>Python dictionary, containing pairs of key: value.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.calibrate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.calibrate">#&nbsp;&nbsp</a>

                <div class="decorator">@change_x</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">calibrate</span><span class="signature">(self, calibration)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_x</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration : RamanCalibration</span>
<span class="sd">            &gt; Calibration object for the x  axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate Raman shift corrections</span>
        <span class="n">x_shifts</span> <span class="o">=</span> <span class="n">calibration</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Substitute with new x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x_shifts</span>
        <span class="c1"># Make sure x values remain sorted</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Calibrate the x axis.</p>

<h2 id="parameters">Parameters</h2>

<p>calibration : RamanCalibration</p>

<blockquote>
  <p>Calibration object for the x  axis.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.make_x_calibration" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.make_x_calibration">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">make_x_calibration</span><span class="signature">(self, reference, fitmethod=&#39;voigt&#39;, peak_pos=[])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">make_x_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span> <span class="o">=</span> <span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">peak_pos</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an x axis calibration, either to a RamanSpectrum or a list of exact reference peak positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum or list</span>
<span class="sd">            &gt; Reference for calibration.</span>
<span class="sd">            If RamanSpectrum, the reference must be a spectrum recorded using the same sample, and calibrated.</span>
<span class="sd">            If list, the reference must be a list of exact peak positions.</span>
<span class="sd">            </span>
<span class="sd">        fitmethod : str, optional</span>
<span class="sd">            &gt; Model to fit to each peak of Target and Reference  </span>
<span class="sd">            - &#39;par&#39;: parabola  </span>
<span class="sd">            - &#39;voigt&#39;: Voigt distribution  </span>
<span class="sd">            - &#39;vg&#39;: Sum of independent Gauss + Voigt model  </span>
<span class="sd">            The default is &#39;voigt&#39;.</span>

<span class="sd">        peak_pos : list, optional</span>
<span class="sd">            &gt; Only if reference is a RamanSpectrum: peak positions that should be fit and included in the calibration.</span>
<span class="sd">            The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCalibration</span>
<span class="sd">            &gt; Calibration object containing the relative shifts as well as a polynomial interpolation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Returns a RamanCalibration</span>
        <span class="c1"># If a Raman spectrum is given as refernece</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RamanSpectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;RamanChada&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">raman_x_calibration_from_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">peak_pos</span><span class="o">=</span><span class="n">peak_pos</span><span class="p">)</span>
        <span class="c1"># If a list of peak positions is given</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">raman_x_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generate an x axis calibration, either to a RamanSpectrum or a list of exact reference peak positions.</p>

<h2 id="parameters">Parameters</h2>

<p>reference : RamanSpectrum or list</p>

<blockquote>
  <p>Reference for calibration.
      If RamanSpectrum, the reference must be a spectrum recorded using the same sample, and calibrated.
      If list, the reference must be a list of exact peak positions.</p>
</blockquote>

<p>fitmethod : str, optional</p>

<blockquote>
  <p>Model to fit to each peak of Target and Reference <br />
      - 'par': parabola <br />
      - 'voigt': Voigt distribution <br />
      - 'vg': Sum of independent Gauss + Voigt model <br />
      The default is 'voigt'.</p>
</blockquote>

<p>peak_pos : list, optional</p>

<blockquote>
  <p>Only if reference is a RamanSpectrum: peak positions that should be fit and included in the calibration.
      The default is [].</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>RamanCalibration</p>

<blockquote>
  <p>Calibration object containing the relative shifts as well as a polynomial interpolation.</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanSpectrum.calibrate_y" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.calibrate_y">#&nbsp;&nbsp</a>

                <div class="decorator">@change_y</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">calibrate_y</span><span class="signature">(self, calibration)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">calibrate_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the y axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration : RamanCalibration</span>
<span class="sd">            &gt; Calibration object for the y  axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate Raman gain corrections</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">calibration</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">gain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calibration not in data range!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Apply gain correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">gain</span>
</pre></div>

        </details>

            <div class="docstring"><p>Calibrate the y axis.</p>

<h2 id="parameters">Parameters</h2>

<p>calibration : RamanCalibration</p>

<blockquote>
  <p>Calibration object for the y  axis.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.make_y_calibration" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.make_y_calibration">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">make_y_calibration</span><span class="signature">(self, reference, x_min=-1000000000.0, x_max=1000000000.0)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">make_y_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=-</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">1e9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an y axis calibration to a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum</span>
<span class="sd">            &gt; The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</span>
<span class="sd">            </span>
<span class="sd">        x_min : double</span>
<span class="sd">            &gt; Lower x boundary of calibration interval in x units</span>
<span class="sd">            </span>
<span class="sd">        x_max : double</span>
<span class="sd">            &gt; Upper x boundary of calibration interval in x units.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCalibration</span>
<span class="sd">            &gt; Calibration object containing the relative gain as well as a polynomial interpolation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">raman_y_calibration_from_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">x_max</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generate an y axis calibration to a RamanSpectrum.</p>

<h2 id="parameters">Parameters</h2>

<p>reference : RamanSpectrum</p>

<blockquote>
  <p>The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</p>
</blockquote>

<p>x_min : double</p>

<blockquote>
  <p>Lower x boundary of calibration interval in x units</p>
</blockquote>

<p>x_max : double</p>

<blockquote>
  <p>Upper x boundary of calibration interval in x units.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>RamanCalibration</p>

<blockquote>
  <p>Calibration object containing the relative gain as well as a polynomial interpolation.</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanSpectrum.deconvolve_MTF" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.deconvolve_MTF">#&nbsp;&nbsp</a>

                <div class="decorator">@change_y</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">deconvolve_MTF</span><span class="signature">(self, mtf, gauss_filter_sigma=1)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">deconvolve_MTF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mtf</span><span class="p">,</span> <span class="n">gauss_filter_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolves an MTF from a RamanSpectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mtf : RamanMTF</span>
<span class="sd">            &gt; MTF object containing the MTF model in Fourier space.</span>
<span class="sd">            </span>
<span class="sd">        gauss_filter_sigma : double, optional</span>
<span class="sd">            &gt; Sigma of a Gauss filter applied after deconvolution to reduce excessive noise. The default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">deconvolve_mtf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">mtf</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gauss_filter_sigma</span><span class="o">=</span><span class="n">gauss_filter_sigma</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Deconvolves an MTF from a RamanSpectrum.</p>

<h2 id="parameters">Parameters</h2>

<p>mtf : RamanMTF</p>

<blockquote>
  <p>MTF object containing the MTF model in Fourier space.</p>
</blockquote>

<p>gauss_filter_sigma : double, optional</p>

<blockquote>
  <p>Sigma of a Gauss filter applied after deconvolution to reduce excessive noise. The default is 1.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.make_res_calibration" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.make_res_calibration">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">make_res_calibration</span><span class="signature">(self, reference)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">make_res_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the resolution (peak broadening) to that of a reference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : RamanSpectrum</span>
<span class="sd">            &gt; The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanCTF</span>
<span class="sd">            &gt; Object containing the model of ther relative point spread function in Fourier space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use copies to not mess with data here</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">tar</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># crop ref to intersection</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">tar</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()])</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">tar</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">x_crop</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="c1"># interpolate both to common x with delta = 1/cm</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="c1"># normalize</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
        <span class="c1"># calc rel. CTF</span>
        <span class="n">rel_k</span><span class="p">,</span> <span class="n">rel_ctf</span> <span class="o">=</span> <span class="n">relative_ctf</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tar</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ctf_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">ctf_data</span><span class="p">[</span><span class="s1">&#39;spatial frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_k</span>
        <span class="n">ctf_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_ctf</span>
        <span class="k">return</span> <span class="n">RamanCTF</span><span class="p">(</span><span class="n">ctf_data</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Calibrate the resolution (peak broadening) to that of a reference.</p>

<h2 id="parameters">Parameters</h2>

<p>reference : RamanSpectrum</p>

<blockquote>
  <p>The reference must be a spectrum recorded using the same sample, and calibrated in x and y.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>RamanCTF</p>

<blockquote>
  <p>Object containing the model of ther relative point spread function in Fourier space.</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanSpectrum.set_resolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.set_resolution">#&nbsp;&nbsp</a>

                <div class="decorator">@change_x</div>
        <div class="decorator">@change_y</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">set_resolution</span><span class="signature">(self, rel_ctf)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_x</span>
    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">set_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a relative CTF to a RamanSpectrum</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rel_ctf : RamanCTF</span>
<span class="sd">            &gt; Object containing the model of ther relative point spread function in Fourier space.</span>
<span class="sd">            When applied, the resolution is approximated to that of the reference instrument with which the CTF was calibrated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x values must be equally spaced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">apply_relative_ctf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rel_ctf</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Apply a relative CTF to a RamanSpectrum</p>

<h2 id="parameters">Parameters</h2>

<p>rel_ctf : RamanCTF</p>

<blockquote>
  <p>Object containing the model of ther relative point spread function in Fourier space.
      When applied, the resolution is approximated to that of the reference instrument with which the CTF was calibrated.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.fit_xrays" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.fit_xrays">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit_xrays</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit_xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits a model for cosmic rays (x rays) to the y data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xrays</span> <span class="o">=</span> <span class="n">xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fits a model for cosmic rays (x rays) to the y data.</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.remove_xrays" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.remove_xrays">#&nbsp;&nbsp</a>

                <div class="decorator">@change_y</div>
        <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">remove_xrays</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@change_y</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">remove_xrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes cosmic rays by subtracting the model stored in .xrays (if it exists).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xrays&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xrays</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Removes cosmic rays by subtracting the model stored in .xrays (if it exists).</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanSpectrum.get_snr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanSpectrum.get_snr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_snr</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximates the signal-to-noise ratio of a Raman spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : double</span>
<span class="sd">            &gt; Approximation for SNR.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">snr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Approximates the signal-to-noise ratio of a Raman spectrum.</p>

<h2 id="returns">Returns</h2>

<p>snr : double</p>

<blockquote>
  <p>Approximation for SNR.</p>
</blockquote>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Spectrum">Spectrum</a></dt>
                                <dd id="RamanSpectrum.invert" class="function"><a href="#Spectrum.invert">invert</a></dd>
                <dd id="RamanSpectrum.peaks" class="function"><a href="#Spectrum.peaks">peaks</a></dd>
                <dd id="RamanSpectrum.show_bands" class="function"><a href="#Spectrum.show_bands">show_bands</a></dd>
                <dd id="RamanSpectrum.fit_baseline" class="function"><a href="#Spectrum.fit_baseline">fit_baseline</a></dd>
                <dd id="RamanSpectrum.remove_baseline" class="function"><a href="#Spectrum.remove_baseline">remove_baseline</a></dd>
                <dd id="RamanSpectrum.interpolate_x" class="function"><a href="#Spectrum.interpolate_x">interpolate_x</a></dd>
                <dd id="RamanSpectrum.hqi" class="function"><a href="#Spectrum.hqi">hqi</a></dd>
                <dd id="RamanSpectrum.math" class="function"><a href="#Spectrum.math">math</a></dd>

            </div>
            <div><dt><a href="#Curve">Curve</a></dt>
                                <dd id="RamanSpectrum.plot" class="function"><a href="#Curve.plot">plot</a></dd>
                <dd id="RamanSpectrum.normalize" class="function"><a href="#Curve.normalize">normalize</a></dd>
                <dd id="RamanSpectrum.smooth" class="function"><a href="#Curve.smooth">smooth</a></dd>
                <dd id="RamanSpectrum.x_crop" class="function"><a href="#Curve.x_crop">x_crop</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RamanChada">
                                <div class="attr class">
        <a class="headerlink" href="#RamanChada">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RamanChada</span><wbr>(<span class="base"><a href="#RamanSpectrum">RamanSpectrum</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RamanChada</span><span class="p">(</span><span class="n">RamanSpectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raman CHADA file with logging and saving to disc. Inherits from RamanSpectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;Raman shift [rel. 1/cm]&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;counts [1]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_path : str</span>
<span class="sd">            &gt; Path to spectrum data file that is to be read.</span>
<span class="sd">            If extension is .cha, an existing CHADA file will be opened.</span>
<span class="sd">            If not, a native data file is imported and a CHADA file with the same name generated in the same directory.</span>
<span class="sd">            </span>
<span class="sd">        commit : str, optional</span>
<span class="sd">            &gt; If specified, the data of the specific commit is loaded rather than the most recent. The default is [].</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; See RamanSpectrum. The default is &#39;Raman shift [rel. 1/cm]&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : str, optional</span>
<span class="sd">            &gt; See RamanSpectrum. The default is &#39;counts [1]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If file is not CHADA, create from native</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">source_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.cha&#39;</span><span class="p">:</span>
            <span class="n">source_path</span> <span class="o">=</span> <span class="n">create_chada_from_native</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">read_chada</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">source_path</span>
        <span class="c1"># Initialize log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Save original state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">show_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows the log.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">,</span> <span class="s1">&#39;keyword args&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rewind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the object and data to a past state as listed in the log.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : signed int</span>
<span class="sd">            &gt; If positive, it sets the object to a past state as listed in the log.</span>
<span class="sd">            If negative, resets the object by -state steps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get log up to state</span>
        <span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">[:</span><span class="n">state</span><span class="p">]</span>
        <span class="c1"># empty log (gets populated upon execution of methods)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
            <span class="c1"># Make function from log info</span>
            <span class="c1"># log lines are l = [&#39;time&#39;, &#39;methodname&#39;, &#39;args&#39;, &#39;kwargs&#39;]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commit_text</span><span class="o">=</span><span class="s2">&quot;current&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a commit to the CHADA file by saving the current state to a new dataset within the existing HDF5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        commit : str, optional</span>
<span class="sd">            &gt; Name as reference for commit. The default is &#39;current&#39;.</span>
<span class="sd">            Cannot be &#39;raw&#39;, since the first commit after conversion (the raw data) cannot be edited.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commit_chada</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commit_text</span><span class="p">)</span>
        <span class="c1"># Initialize log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raman CHADA file with logging and saving to disc. Inherits from RamanSpectrum.</p>
</div>


                            <div id="RamanChada.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanChada.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RamanChada</span><span class="signature">(
    source_path,
    raw=False,
    x_label=&#39;Raman shift [rel. 1/cm]&#39;,
    y_label=&#39;counts [1]&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">x_label</span><span class="o">=</span><span class="s1">&#39;Raman shift [rel. 1/cm]&#39;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s1">&#39;counts [1]&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_path : str</span>
<span class="sd">            &gt; Path to spectrum data file that is to be read.</span>
<span class="sd">            If extension is .cha, an existing CHADA file will be opened.</span>
<span class="sd">            If not, a native data file is imported and a CHADA file with the same name generated in the same directory.</span>
<span class="sd">            </span>
<span class="sd">        commit : str, optional</span>
<span class="sd">            &gt; If specified, the data of the specific commit is loaded rather than the most recent. The default is [].</span>
<span class="sd">            </span>
<span class="sd">        x_label : str, optional</span>
<span class="sd">            &gt; See RamanSpectrum. The default is &#39;Raman shift [rel. 1/cm]&#39;.</span>
<span class="sd">            </span>
<span class="sd">        y_label : str, optional</span>
<span class="sd">            &gt; See RamanSpectrum. The default is &#39;counts [1]&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If file is not CHADA, create from native</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">source_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.cha&#39;</span><span class="p">:</span>
            <span class="n">source_path</span> <span class="o">=</span> <span class="n">create_chada_from_native</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">read_chada</span><span class="p">(</span><span class="n">source_path</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">source_path</span>
        <span class="c1"># Initialize log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Save original state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>source_path : str</p>

<blockquote>
  <p>Path to spectrum data file that is to be read.
      If extension is .cha, an existing CHADA file will be opened.
      If not, a native data file is imported and a CHADA file with the same name generated in the same directory.</p>
</blockquote>

<p>commit : str, optional</p>

<blockquote>
  <p>If specified, the data of the specific commit is loaded rather than the most recent. The default is [].</p>
</blockquote>

<p>x_label : str, optional</p>

<blockquote>
  <p>See RamanSpectrum. The default is 'Raman shift [rel. 1/cm]'.</p>
</blockquote>

<p>y_label : str, optional</p>

<blockquote>
  <p>See RamanSpectrum. The default is 'counts [1]'.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanChada.show_log" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanChada.show_log">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">show_log</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">show_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows the log.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">,</span> <span class="s1">&#39;keyword args&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Shows the log.</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanChada.rewind" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanChada.rewind">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">rewind</span><span class="signature">(self, state)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">rewind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the object and data to a past state as listed in the log.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : signed int</span>
<span class="sd">            &gt; If positive, it sets the object to a past state as listed in the log.</span>
<span class="sd">            If negative, resets the object by -state steps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get log up to state</span>
        <span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">[:</span><span class="n">state</span><span class="p">]</span>
        <span class="c1"># empty log (gets populated upon execution of methods)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
            <span class="c1"># Make function from log info</span>
            <span class="c1"># log lines are l = [&#39;time&#39;, &#39;methodname&#39;, &#39;args&#39;, &#39;kwargs&#39;]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the object and data to a past state as listed in the log.</p>

<h2 id="parameters">Parameters</h2>

<p>state : signed int</p>

<blockquote>
  <p>If positive, it sets the object to a past state as listed in the log.
      If negative, resets the object by -state steps.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanChada.commit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanChada.commit">#&nbsp;&nbsp</a>

                <div class="decorator">@log</div>

            <span class="def">def</span>
            <span class="name">commit</span><span class="signature">(self, commit_text=&#39;current&#39;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@log</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commit_text</span><span class="o">=</span><span class="s2">&quot;current&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a commit to the CHADA file by saving the current state to a new dataset within the existing HDF5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        commit : str, optional</span>
<span class="sd">            &gt; Name as reference for commit. The default is &#39;current&#39;.</span>
<span class="sd">            Cannot be &#39;raw&#39;, since the first commit after conversion (the raw data) cannot be edited.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commit_chada</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commit_text</span><span class="p">)</span>
        <span class="c1"># Initialize log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Makes a commit to the CHADA file by saving the current state to a new dataset within the existing HDF5 file.</p>

<h2 id="parameters">Parameters</h2>

<p>commit : str, optional</p>

<blockquote>
  <p>Name as reference for commit. The default is 'current'.
      Cannot be 'raw', since the first commit after conversion (the raw data) cannot be edited.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RamanSpectrum">RamanSpectrum</a></dt>
                                <dd id="RamanChada.add_metadata" class="function"><a href="#RamanSpectrum.add_metadata">add_metadata</a></dd>
                <dd id="RamanChada.calibrate" class="function"><a href="#RamanSpectrum.calibrate">calibrate</a></dd>
                <dd id="RamanChada.make_x_calibration" class="function"><a href="#RamanSpectrum.make_x_calibration">make_x_calibration</a></dd>
                <dd id="RamanChada.calibrate_y" class="function"><a href="#RamanSpectrum.calibrate_y">calibrate_y</a></dd>
                <dd id="RamanChada.make_y_calibration" class="function"><a href="#RamanSpectrum.make_y_calibration">make_y_calibration</a></dd>
                <dd id="RamanChada.deconvolve_MTF" class="function"><a href="#RamanSpectrum.deconvolve_MTF">deconvolve_MTF</a></dd>
                <dd id="RamanChada.make_res_calibration" class="function"><a href="#RamanSpectrum.make_res_calibration">make_res_calibration</a></dd>
                <dd id="RamanChada.set_resolution" class="function"><a href="#RamanSpectrum.set_resolution">set_resolution</a></dd>
                <dd id="RamanChada.fit_xrays" class="function"><a href="#RamanSpectrum.fit_xrays">fit_xrays</a></dd>
                <dd id="RamanChada.remove_xrays" class="function"><a href="#RamanSpectrum.remove_xrays">remove_xrays</a></dd>
                <dd id="RamanChada.get_snr" class="function"><a href="#RamanSpectrum.get_snr">get_snr</a></dd>

            </div>
            <div><dt><a href="#Spectrum">Spectrum</a></dt>
                                <dd id="RamanChada.invert" class="function"><a href="#Spectrum.invert">invert</a></dd>
                <dd id="RamanChada.peaks" class="function"><a href="#Spectrum.peaks">peaks</a></dd>
                <dd id="RamanChada.show_bands" class="function"><a href="#Spectrum.show_bands">show_bands</a></dd>
                <dd id="RamanChada.fit_baseline" class="function"><a href="#Spectrum.fit_baseline">fit_baseline</a></dd>
                <dd id="RamanChada.remove_baseline" class="function"><a href="#Spectrum.remove_baseline">remove_baseline</a></dd>
                <dd id="RamanChada.interpolate_x" class="function"><a href="#Spectrum.interpolate_x">interpolate_x</a></dd>
                <dd id="RamanChada.hqi" class="function"><a href="#Spectrum.hqi">hqi</a></dd>
                <dd id="RamanChada.math" class="function"><a href="#Spectrum.math">math</a></dd>

            </div>
            <div><dt><a href="#Curve">Curve</a></dt>
                                <dd id="RamanChada.plot" class="function"><a href="#Curve.plot">plot</a></dd>
                <dd id="RamanChada.normalize" class="function"><a href="#Curve.normalize">normalize</a></dd>
                <dd id="RamanChada.smooth" class="function"><a href="#Curve.smooth">smooth</a></dd>
                <dd id="RamanChada.x_crop" class="function"><a href="#Curve.x_crop">x_crop</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="make_test_RamanChada">
                            <div class="attr function"><a class="headerlink" href="#make_test_RamanChada">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">make_test_RamanChada</span><span class="signature">()</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_test_RamanChada</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates test spctrum</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    RamanChada</span>
<span class="sd">        &gt; Spectrum of a organic compound with several peaks as RamanChada.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="s2">&quot;testdata&quot;</span><span class="p">,</span> <span class="s2">&quot;200218-17.wdf&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">RamanChada</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generates test spctrum</p>

<h2 id="parameters">Parameters</h2>

<p>None.</p>

<h2 id="returns">Returns</h2>

<p>RamanChada</p>

<blockquote>
  <p>Spectrum of a organic compound with several peaks as RamanChada.</p>
</blockquote>
</div>


                </section>
                <section id="SpectrumGroup">
                                <div class="attr class">
        <a class="headerlink" href="#SpectrumGroup">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SpectrumGroup</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SpectrumGroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group of spectra for comparison and multivariate analysis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : RamanSpectrum, optional</span>
<span class="sd">            &gt; Raman spectra to be contained upon initialization. The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info1</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> containing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">)</span><span class="si">}</span><span class="s1"> objects.&#39;</span>
        <span class="n">info2</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Object type(s): </span><span class="si">{</span><span class="nb">set</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info1</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">info2</span>
        <span class="k">return</span> <span class="n">info</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a RamanSpectrum to the Group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectrum : RamanSpectrum</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y_label</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="s1">&#39;meta&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">))</span>
    <span class="nd">@specstyle</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot all contained spectra into a single graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leg : bool, optional</span>
<span class="sd">            &gt; True if a legend should be shown. The default is True.</span>
<span class="sd">            If unspecified, legend labelsare set to file names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leg</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="c1">#    - add_labels</span>
<span class="c1">#    - add_targets</span>
    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_increment</span><span class="o">=</span><span class="mf">.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate all spectra to a common x axis and Export as Numpy array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_increment : double, optional</span>
<span class="sd">            &gt; Spectral increment (resolution) of the common x axis. The default is 0.5.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Matrix containing all spectra in Group as lines.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Boundaries of intersection</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span>
        <span class="c1"># Make common x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">x_increment</span><span class="p">)</span>
        <span class="c1"># for all</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># interpolate to x</span>
            <span class="n">f_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_inter</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a specified method to separately to each spectrum in the group.</span>
<span class="sd">        Example:</span>
<span class="sd">            </span>
<span class="sd">            G.process(&#39;x_crop&#39;, 500, 1800)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            &gt; Name of method to be applied</span>
<span class="sd">            </span>
<span class="sd">        *args</span>
<span class="sd">            &gt; Non-keyword agruments for method. Refer to method documentation.</span>
<span class="sd">            </span>
<span class="sd">        **kwargs : TYPE</span>
<span class="sd">            &gt; Keyword agruments for method. Refer to method documentation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for indexed spectra</span>
        <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># search for method in class object</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="c1"># Apply method with args</span>
                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span> <span class="k">raise</span> <span class="n">err</span>
    <span class="k">def</span> <span class="nf">make_mtf_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract x rays from grouped spectra and generate a model from the average MTF in Fourier space.</span>
<span class="sd">        This is suitable if the Group consists of a time series, which is likely to contain one or more x rays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanMTF</span>
<span class="sd">            &gt; MTF model in Fourier space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xray_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="n">xray_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extract_xrays</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xray_list</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; xrays found in Group&#39;</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">mtf</span> <span class="o">=</span> <span class="n">raman_mtf_from_psfs</span><span class="p">(</span><span class="n">xray_list</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculated MTF with amlitude = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mtf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; at full Nyquist.&#39;</span><span class="p">)</span>
        <span class="n">mtf_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">mtf_data</span><span class="p">[</span><span class="s1">&#39;Nyquist frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">mtf_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtf</span>
        <span class="k">return</span> <span class="n">RamanMTF</span><span class="p">(</span><span class="n">mtf_data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">round_robin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_pos</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the x position of a list of specified peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fitmethod : str</span>
<span class="sd">            &gt; Name of peak fit model to be applied</span>
<span class="sd">            </span>
<span class="sd">        interval_width : int</span>
<span class="sd">            &gt; Interval in multiples of FWHM around the peak to be used for peak fitting.  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            &gt; *DataFrame* containing standard and fitted peak positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># Fit peaks for each spectrum</span>
            <span class="n">s</span><span class="o">.</span><span class="n">peaks</span><span class="p">(</span><span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="n">interval_width</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Select peak closest to indicated reference pos</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">peak_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="n">ref_pos</span><span class="p">))</span>
                <span class="c1"># Combnine DataFrame from target peaks</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">peak_line</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">generate_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pivot_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Make list of filenames without path and ext.</span>
        <span class="n">data_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">labels_from_filenames</span><span class="p">(</span><span class="n">data_labels</span><span class="p">,</span> <span class="n">pivot_string</span><span class="o">=</span><span class="n">pivot_string</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="n">numeric</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Group of spectra for comparison and multivariate analysis</p>
</div>


                            <div id="SpectrumGroup.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SpectrumGroup</span><span class="signature">(spectra=[])</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : RamanSpectrum, optional</span>
<span class="sd">            &gt; Raman spectra to be contained upon initialization. The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>spectra : RamanSpectrum, optional</p>

<blockquote>
  <p>Raman spectra to be contained upon initialization. The default is [].</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="SpectrumGroup.add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add</span><span class="signature">(self, spectrum)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a RamanSpectrum to the Group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectrum : RamanSpectrum</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y_label</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="s1">&#39;meta&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a RamanSpectrum to the Group.</p>

<h2 id="parameters">Parameters</h2>

<p>spectrum : RamanSpectrum</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="SpectrumGroup.plot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.plot">#&nbsp;&nbsp</a>

                <div class="decorator">@specstyle</div>

            <span class="def">def</span>
            <span class="name">plot</span><span class="signature">(self, leg=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@specstyle</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot all contained spectra into a single graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leg : bool, optional</span>
<span class="sd">            &gt; True if a legend should be shown. The default is True.</span>
<span class="sd">            If unspecified, legend labelsare set to file names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leg</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot all contained spectra into a single graph.</p>

<h2 id="parameters">Parameters</h2>

<p>leg : bool, optional</p>

<blockquote>
  <p>True if a legend should be shown. The default is True.
      If unspecified, legend labelsare set to file names.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="SpectrumGroup.to_array" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.to_array">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_array</span><span class="signature">(self, x_increment=0.5)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_increment</span><span class="o">=</span><span class="mf">.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate all spectra to a common x axis and Export as Numpy array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_increment : double, optional</span>
<span class="sd">            &gt; Spectral increment (resolution) of the common x axis. The default is 0.5.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Matrix containing all spectra in Group as lines.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Boundaries of intersection</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">])</span>
        <span class="c1"># Make common x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">x_increment</span><span class="p">)</span>
        <span class="c1"># for all</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># interpolate to x</span>
            <span class="n">f_inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_inter</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Interpolate all spectra to a common x axis and Export as Numpy array.</p>

<h2 id="parameters">Parameters</h2>

<p>x_increment : double, optional</p>

<blockquote>
  <p>Spectral increment (resolution) of the common x axis. The default is 0.5.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>np.array</p>

<blockquote>
  <p>Matrix containing all spectra in Group as lines.</p>
</blockquote>
</div>


                            </div>
                            <div id="SpectrumGroup.process" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.process">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">process</span><span class="signature">(self, method, *args, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a specified method to separately to each spectrum in the group.</span>
<span class="sd">        Example:</span>
<span class="sd">            </span>
<span class="sd">            G.process(&#39;x_crop&#39;, 500, 1800)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            &gt; Name of method to be applied</span>
<span class="sd">            </span>
<span class="sd">        *args</span>
<span class="sd">            &gt; Non-keyword agruments for method. Refer to method documentation.</span>
<span class="sd">            </span>
<span class="sd">        **kwargs : TYPE</span>
<span class="sd">            &gt; Keyword agruments for method. Refer to method documentation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for indexed spectra</span>
        <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># search for method in class object</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="c1"># Apply method with args</span>
                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span> <span class="k">raise</span> <span class="n">err</span>
</pre></div>

        </details>

            <div class="docstring"><p>Applies a specified method to separately to each spectrum in the group.
Example:</p>

<pre><code>G.process('x_crop', 500, 1800)
</code></pre>

<h2 id="parameters">Parameters</h2>

<p>method : str</p>

<blockquote>
  <p>Name of method to be applied</p>
</blockquote>

<p>*args</p>

<blockquote>
  <p>Non-keyword agruments for method. Refer to method documentation.</p>
</blockquote>

<p>**kwargs : TYPE</p>

<blockquote>
  <p>Keyword agruments for method. Refer to method documentation.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="SpectrumGroup.make_mtf_calibration" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.make_mtf_calibration">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">make_mtf_calibration</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">make_mtf_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract x rays from grouped spectra and generate a model from the average MTF in Fourier space.</span>
<span class="sd">        This is suitable if the Group consists of a time series, which is likely to contain one or more x rays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanMTF</span>
<span class="sd">            &gt; MTF model in Fourier space.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xray_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="n">xray_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extract_xrays</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xray_list</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; xrays found in Group&#39;</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">mtf</span> <span class="o">=</span> <span class="n">raman_mtf_from_psfs</span><span class="p">(</span><span class="n">xray_list</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculated MTF with amlitude = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mtf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; at full Nyquist.&#39;</span><span class="p">)</span>
        <span class="n">mtf_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">mtf_data</span><span class="p">[</span><span class="s1">&#39;Nyquist frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">mtf_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtf</span>
        <span class="k">return</span> <span class="n">RamanMTF</span><span class="p">(</span><span class="n">mtf_data</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extract x rays from grouped spectra and generate a model from the average MTF in Fourier space.
This is suitable if the Group consists of a time series, which is likely to contain one or more x rays.</p>

<h2 id="returns">Returns</h2>

<p>RamanMTF</p>

<blockquote>
  <p>MTF model in Fourier space.</p>
</blockquote>
</div>


                            </div>
                            <div id="SpectrumGroup.round_robin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.round_robin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">round_robin</span><span class="signature">(self, ref_pos, fitmethod=&#39;voigt&#39;, interval_width=2)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">round_robin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_pos</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="s1">&#39;voigt&#39;</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the x position of a list of specified peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fitmethod : str</span>
<span class="sd">            &gt; Name of peak fit model to be applied</span>
<span class="sd">            </span>
<span class="sd">        interval_width : int</span>
<span class="sd">            &gt; Interval in multiples of FWHM around the peak to be used for peak fitting.  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            &gt; *DataFrame* containing standard and fitted peak positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="c1"># Fit peaks for each spectrum</span>
            <span class="n">s</span><span class="o">.</span><span class="n">peaks</span><span class="p">(</span><span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">interval_width</span><span class="o">=</span><span class="n">interval_width</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Select peak closest to indicated reference pos</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">peak_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="n">ref_pos</span><span class="p">))</span>
                <span class="c1"># Combnine DataFrame from target peaks</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">peak_line</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Determines the x position of a list of specified peaks.</p>

<h2 id="parameters">Parameters</h2>

<p>fitmethod : str</p>

<blockquote>
  <p>Name of peak fit model to be applied</p>
</blockquote>

<p>interval_width : int</p>

<blockquote>
  <p>Interval in multiples of FWHM around the peak to be used for peak fitting.  </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>DataFrame</p>

<blockquote>
  <p><em>DataFrame</em> containing standard and fitted peak positions.</p>
</blockquote>
</div>


                            </div>
                            <div id="SpectrumGroup.generate_labels" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SpectrumGroup.generate_labels">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_labels</span><span class="signature">(self, pivot_string=None, pos=0, numeric=True, length=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">generate_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pivot_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Make list of filenames without path and ext.</span>
        <span class="n">data_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectra</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">labels_from_filenames</span><span class="p">(</span><span class="n">data_labels</span><span class="p">,</span> <span class="n">pivot_string</span><span class="o">=</span><span class="n">pivot_string</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="n">numeric</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="RamanGroup">
                                <div class="attr class">
        <a class="headerlink" href="#RamanGroup">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RamanGroup</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RamanGroup</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group of Raman spectra for comparison and multivariate analysis.</span>
<span class="sd">    Contains the spectra in form of a DataFrame in the *.data* attribute</span>
<span class="sd">    with spectra as rows and Raman shifts as columns. The column names are</span>
<span class="sd">    Raman shifts as *float*, while the index is the file basename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : list of *RamanChada* or *RamanSpectrum* objects</span>
<span class="sd">            &gt; Spectra to be included upon initialization.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G = RamanGroup( [s1, s2, s3] )</span>
<span class="sd">            </span>
<span class="sd">        interpolate : bool</span>
<span class="sd">            &gt; If True, Raman shifts are interpolated to increments of 1 1/cm.</span>
<span class="sd">            If False, all x axes will be interpolated to the x axis of the first spectrum added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">first_spectrum</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="n">first_spectrum</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">first_spectrum</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="n">first_spectrum</span><span class="o">.</span><span class="n">y_label</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spectrum_to_frame</span><span class="p">(</span><span class="n">first_spectrum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            
    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">use_new_x</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single spectrum.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectrum : *RamanChada* or *RamanSpectrum* object</span>
<span class="sd">            &gt; Spectrum to be added.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G.add_one(s4)</span>
<span class="sd">            </span>
<span class="sd">        use_new_x : bool</span>
<span class="sd">            &gt; If True, the existing x axes will be interpolated to the newly added spectrum.</span>
<span class="sd">            If False, the x axis will be interpolated on the existing x axes. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert added spectrum to DataFrame with x values as rows</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spectrum_to_frame</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Merge existing self.data with S while using the &#39;outer&#39; union with both sets of x values</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
        <span class="c1"># Interpolate missing values and reindex on original x axis. Fill NaNs with zeros.</span>
        <span class="k">if</span> <span class="n">use_new_x</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">index</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="s1">&#39;quadratic&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a list of spectra.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : list of *RamanChada* or *RamanSpectrum* objects</span>
<span class="sd">            &gt; Spectra to be added.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G.add( [s5, s6] )</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_one</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectra</span> <span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">set_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds targets for plottting prediction model training.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_dict : dict</span>
<span class="sd">            &gt; Targets to be added to the group as dict.</span>
<span class="sd">            Keys are arbitrary target names, while values must be lists</span>
<span class="sd">            or 1-dim arrays with a lenght matching the number of spectra in the *RamanGroup*,</span>
<span class="sd">            i.e. `len(target_dict) = len(G.data)`.</span>
<span class="sd">            Target values can be strings (for classification) or numbers (for regression).</span>
<span class="sd">            The targets are stored in *RamanGroup.targets*, a *DataFrame*.</span>
<span class="sd">            Note that multiple targets can be added.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">target_dict</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_of_spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a specified single spectrum from the *RamanGroup*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        no_of_spectrum : int</span>
<span class="sd">            &gt; Index of the spectrum to be extracted.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanChada</span>
<span class="sd">            &gt; Extracted spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">line_to_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">no_of_spectrum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of a *RamanGroup*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanGroup</span>
<span class="sd">            &gt; Exact copy of *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a single pre-processing step to a *RamanGroup*.</span>
<span class="sd">        Uses the function *ramanchada.models.process_DF*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            &gt; Name of *RamanChada* method to be applied.</span>
<span class="sd">            For details, refer to *ramanchada.RamanChada*.</span>
<span class="sd">            </span>
<span class="sd">        *args : str of number</span>
<span class="sd">            &gt; Non-keyword parameters for method</span>

<span class="sd">        **kwargs</span>
<span class="sd">            &gt; Keyword parameters for method   </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">process_DF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Common x axis of *RamanGroup* as 1D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        np.array</span>
<span class="sd">            &gt; Y values of *RamanGroup* as array with dimensions [n_spectra, n_channels]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> containing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> spectra.&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;targets&#39;</span><span class="p">):</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span><span class="si">}</span><span class="s1"> added&#39;</span>
        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-9</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">],</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots spectra of a *RamanGroup* in a single axis. </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : str</span>
<span class="sd">            &gt; Name of target to be used for hue. If given, spectra with a</span>
<span class="sd">            common target will be represented by their mean spectrum, with</span>
<span class="sd">            a spread corresponding to the standard deviation at each Raman shift.</span>
<span class="sd">            This is particularly useful if a large number of spectra are plotted.</span>
<span class="sd">            The default is None.</span>

<span class="sd">        xrange : list of double [x_min, x_max]</span>
<span class="sd">            &gt; x interval to be plotted. The default is [1e-9, 1e9] (all).</span>

<span class="sd">        legend : bool</span>
<span class="sd">            &gt; If True, a legend will be shown. The default is False. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plot_style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="c1">#target = &#39;times&#39;</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">DF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">))</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">DF</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ci</span><span class="o">=</span><span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="n">n_boot</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Group of Raman spectra for comparison and multivariate analysis.
Contains the spectra in form of a DataFrame in the <em>.data</em> attribute
with spectra as rows and Raman shifts as columns. The column names are
Raman shifts as <em>float</em>, while the index is the file basename.</p>
</div>


                            <div id="RamanGroup.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RamanGroup</span><span class="signature">(spectra, interpolate=True)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : list of *RamanChada* or *RamanSpectrum* objects</span>
<span class="sd">            &gt; Spectra to be included upon initialization.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G = RamanGroup( [s1, s2, s3] )</span>
<span class="sd">            </span>
<span class="sd">        interpolate : bool</span>
<span class="sd">            &gt; If True, Raman shifts are interpolated to increments of 1 1/cm.</span>
<span class="sd">            If False, all x axes will be interpolated to the x axis of the first spectrum added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">first_spectrum</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="n">first_spectrum</span><span class="o">.</span><span class="n">interpolate_x</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="n">first_spectrum</span><span class="o">.</span><span class="n">x_label</span><span class="p">,</span> <span class="n">first_spectrum</span><span class="o">.</span><span class="n">y_label</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spectrum_to_frame</span><span class="p">(</span><span class="n">first_spectrum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>spectra : list of <em>RamanChada</em> or <em>RamanSpectrum</em> objects</p>

<blockquote>
  <p>Spectra to be included upon initialization.
      Example:</p>
</blockquote>

<pre><code>    G = RamanGroup( [s1, s2, s3] )
</code></pre>

<p>interpolate : bool</p>

<blockquote>
  <p>If True, Raman shifts are interpolated to increments of 1 1/cm.
      If False, all x axes will be interpolated to the x axis of the first spectrum added.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanGroup.add_one" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.add_one">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add_one</span><span class="signature">(self, spectrum, use_new_x=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">use_new_x</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single spectrum.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectrum : *RamanChada* or *RamanSpectrum* object</span>
<span class="sd">            &gt; Spectrum to be added.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G.add_one(s4)</span>
<span class="sd">            </span>
<span class="sd">        use_new_x : bool</span>
<span class="sd">            &gt; If True, the existing x axes will be interpolated to the newly added spectrum.</span>
<span class="sd">            If False, the x axis will be interpolated on the existing x axes. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert added spectrum to DataFrame with x values as rows</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spectrum_to_frame</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Merge existing self.data with S while using the &#39;outer&#39; union with both sets of x values</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
        <span class="c1"># Interpolate missing values and reindex on original x axis. Fill NaNs with zeros.</span>
        <span class="k">if</span> <span class="n">use_new_x</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">index</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="s1">&#39;quadratic&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">T</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a single spectrum.</p>

<h2 id="parameters">Parameters</h2>

<p>spectrum : <em>RamanChada</em> or <em>RamanSpectrum</em> object</p>

<blockquote>
  <p>Spectrum to be added.
      Example:</p>
</blockquote>

<pre><code>    G.add_one(s4)
</code></pre>

<p>use_new_x : bool</p>

<blockquote>
  <p>If True, the existing x axes will be interpolated to the newly added spectrum.
      If False, the x axis will be interpolated on the existing x axes. The default is False.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanGroup.add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add</span><span class="signature">(self, spectra)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a list of spectra.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectra : list of *RamanChada* or *RamanSpectrum* objects</span>
<span class="sd">            &gt; Spectra to be added.</span>
<span class="sd">            Example:</span>
<span class="sd">            </span>
<span class="sd">                G.add( [s5, s6] )</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_one</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spectra</span> <span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a list of spectra.</p>

<h2 id="parameters">Parameters</h2>

<p>spectra : list of <em>RamanChada</em> or <em>RamanSpectrum</em> objects</p>

<blockquote>
  <p>Spectra to be added.
      Example:</p>
</blockquote>

<pre><code>    G.add( [s5, s6] )
</code></pre>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanGroup.set_targets" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.set_targets">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_targets</span><span class="signature">(self, target_dict)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds targets for plottting prediction model training.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_dict : dict</span>
<span class="sd">            &gt; Targets to be added to the group as dict.</span>
<span class="sd">            Keys are arbitrary target names, while values must be lists</span>
<span class="sd">            or 1-dim arrays with a lenght matching the number of spectra in the *RamanGroup*,</span>
<span class="sd">            i.e. `len(target_dict) = len(G.data)`.</span>
<span class="sd">            Target values can be strings (for classification) or numbers (for regression).</span>
<span class="sd">            The targets are stored in *RamanGroup.targets*, a *DataFrame*.</span>
<span class="sd">            Note that multiple targets can be added.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">target_dict</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds targets for plottting prediction model training.</p>

<h2 id="parameters">Parameters</h2>

<p>target_dict : dict</p>

<blockquote>
  <p>Targets to be added to the group as dict.
      Keys are arbitrary target names, while values must be lists
      or 1-dim arrays with a lenght matching the number of spectra in the <em>RamanGroup</em>,
      i.e. <code>len(target_dict) = len(G.data)</code>.
      Target values can be strings (for classification) or numbers (for regression).
      The targets are stored in <em>RamanGroup.targets</em>, a <em>DataFrame</em>.
      Note that multiple targets can be added.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanGroup.extract" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.extract">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extract</span><span class="signature">(self, no_of_spectrum)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_of_spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a specified single spectrum from the *RamanGroup*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        no_of_spectrum : int</span>
<span class="sd">            &gt; Index of the spectrum to be extracted.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanChada</span>
<span class="sd">            &gt; Extracted spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">line_to_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">no_of_spectrum</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a specified single spectrum from the <em>RamanGroup</em>.</p>

<h2 id="parameters">Parameters</h2>

<p>no_of_spectrum : int</p>

<blockquote>
  <p>Index of the spectrum to be extracted.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>RamanChada</p>

<blockquote>
  <p>Extracted spectrum</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanGroup.clone" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.clone">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">clone</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of a *RamanGroup*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RamanGroup</span>
<span class="sd">            &gt; Exact copy of *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a deep copy of a <em>RamanGroup</em>.</p>

<h2 id="parameters">Parameters</h2>

<p>None.</p>

<h2 id="returns">Returns</h2>

<p>RamanGroup</p>

<blockquote>
  <p>Exact copy of <em>self</em>.</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanGroup.process" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.process">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">process</span><span class="signature">(self, method, *args, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a single pre-processing step to a *RamanGroup*.</span>
<span class="sd">        Uses the function *ramanchada.models.process_DF*.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            &gt; Name of *RamanChada* method to be applied.</span>
<span class="sd">            For details, refer to *ramanchada.RamanChada*.</span>
<span class="sd">            </span>
<span class="sd">        *args : str of number</span>
<span class="sd">            &gt; Non-keyword parameters for method</span>

<span class="sd">        **kwargs</span>
<span class="sd">            &gt; Keyword parameters for method   </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">process_DF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Applies a single pre-processing step to a <em>RamanGroup</em>.
Uses the function <em><a href="models.html#process_DF">ramanchada.models.process_DF</a></em>.</p>

<h2 id="parameters">Parameters</h2>

<p>method : str</p>

<blockquote>
  <p>Name of <em>RamanChada</em> method to be applied.
      For details, refer to <em><a href="../ramanchada.html#RamanChada">ramanchada.RamanChada</a></em>.</p>
</blockquote>

<p>*args : str of number</p>

<blockquote>
  <p>Non-keyword parameters for method</p>
</blockquote>

<p>**kwargs</p>

<blockquote>
  <p>Keyword parameters for method   </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanGroup.x" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RamanGroup.x">#&nbsp;&nbsp</a>

        <span class="name">x</span>
    </div>

            <div class="docstring"><p>np.array</p>

<blockquote>
  <p>Common x axis of <em>RamanGroup</em> as 1D array</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanGroup.y" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RamanGroup.y">#&nbsp;&nbsp</a>

        <span class="name">y</span>
    </div>

            <div class="docstring"><p>np.array</p>

<blockquote>
  <p>Y values of <em>RamanGroup</em> as array with dimensions [n_spectra, n_channels]</p>
</blockquote>
</div>


                            </div>
                            <div id="RamanGroup.plot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanGroup.plot">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot</span><span class="signature">(self, target=None, xrange=[1e-09, 1000000000.0], legend=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xrange</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-9</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">],</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots spectra of a *RamanGroup* in a single axis. </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : str</span>
<span class="sd">            &gt; Name of target to be used for hue. If given, spectra with a</span>
<span class="sd">            common target will be represented by their mean spectrum, with</span>
<span class="sd">            a spread corresponding to the standard deviation at each Raman shift.</span>
<span class="sd">            This is particularly useful if a large number of spectra are plotted.</span>
<span class="sd">            The default is None.</span>

<span class="sd">        xrange : list of double [x_min, x_max]</span>
<span class="sd">            &gt; x interval to be plotted. The default is [1e-9, 1e9] (all).</span>

<span class="sd">        legend : bool</span>
<span class="sd">            &gt; If True, a legend will be shown. The default is False. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plot_style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="c1">#target = &#39;times&#39;</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">DF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">))</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">DF</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ci</span><span class="o">=</span><span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="n">n_boot</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots spectra of a <em>RamanGroup</em> in a single axis. </p>

<h2 id="parameters">Parameters</h2>

<p>target : str</p>

<blockquote>
  <p>Name of target to be used for hue. If given, spectra with a
      common target will be represented by their mean spectrum, with
      a spread corresponding to the standard deviation at each Raman shift.
      This is particularly useful if a large number of spectra are plotted.
      The default is None.</p>
</blockquote>

<p>xrange : list of double [x_min, x_max]</p>

<blockquote>
  <p>x interval to be plotted. The default is [1e-9, 1e9] (all).</p>
</blockquote>

<p>legend : bool</p>

<blockquote>
  <p>If True, a legend will be shown. The default is False. </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                </section>
                <section id="RamanCalibration">
                                <div class="attr class">
        <a class="headerlink" href="#RamanCalibration">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RamanCalibration</span><wbr>(<span class="base"><a href="#Curve">Curve</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RamanCalibration</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing a Raman x axis calibration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3500</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">poly_degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : DataFrame</span>
<span class="sd">            &gt; DataFrame with two columns, the first containing the x positions and the second containing the shifts at these positions.</span>
<span class="sd">            </span>
<span class="sd">        poly_degree : int, optional</span>
<span class="sd">            &gt; Degree of polynomial model fitted to the data points. The default is 3.</span>
<span class="sd">            </span>
<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            &gt; If True, values of the polynomial model which are outside of the data range used for calibration are interpolated.</span>
<span class="sd">            If False, all shifts outside the data range are set to the boundary values.</span>
<span class="sd">            The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># fit shift vector</span>
        <span class="c1"># If specified, use 1d linear interpolation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only apply shift within x limits of calibration data</span>
                <span class="c1"># Set shifts outside the limits to boundary values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">interpolation_within_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the calibration data points and the associated model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_x</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Object containing a Raman x axis calibration.</p>
</div>


                            <div id="RamanCalibration.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanCalibration.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RamanCalibration</span><span class="signature">(data, poly_degree=3, interpolate=False)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">poly_degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : DataFrame</span>
<span class="sd">            &gt; DataFrame with two columns, the first containing the x positions and the second containing the shifts at these positions.</span>
<span class="sd">            </span>
<span class="sd">        poly_degree : int, optional</span>
<span class="sd">            &gt; Degree of polynomial model fitted to the data points. The default is 3.</span>
<span class="sd">            </span>
<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            &gt; If True, values of the polynomial model which are outside of the data range used for calibration are interpolated.</span>
<span class="sd">            If False, all shifts outside the data range are set to the boundary values.</span>
<span class="sd">            The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># fit shift vector</span>
        <span class="c1"># If specified, use 1d linear interpolation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only apply shift within x limits of calibration data</span>
                <span class="c1"># Set shifts outside the limits to boundary values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span> <span class="o">=</span> <span class="n">interpolation_within_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">poly_degree</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>data : DataFrame</p>

<blockquote>
  <p>DataFrame with two columns, the first containing the x positions and the second containing the shifts at these positions.</p>
</blockquote>

<p>poly_degree : int, optional</p>

<blockquote>
  <p>Degree of polynomial model fitted to the data points. The default is 3.</p>
</blockquote>

<p>interpolate : bool, optional</p>

<blockquote>
  <p>If True, values of the polynomial model which are outside of the data range used for calibration are interpolated.
      If False, all shifts outside the data range are set to the boundary values.
      The default is False.</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div id="RamanCalibration.test_x" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RamanCalibration.test_x">#&nbsp;&nbsp</a>

        <span class="name">test_x</span><span class="default_value"> = array([   0.        ,   35.35353535,   70.70707071,  106.06060606,
        141.41414141,  176.76767677,  212.12121212,  247.47474747,
        282.82828283,  318.18181818,  353.53535354,  388.88888889,
        424.24242424,  459.5959596 ,  494.94949495,  530.3030303 ,
        565.65656566,  601.01010101,  636.36363636,  671.71717172,
        707.07070707,  742.42424242,  777.77777778,  813.13131313,
        848.48484848,  883.83838384,  919.19191919,  954.54545455,
        989.8989899 , 1025.25252525, 1060.60606061, 1095.95959596,
       1131.31313131, 1166.66666667, 1202.02020202, 1237.37373737,
       1272.72727273, 1308.08080808, 1343.43434343, 1378.78787879,
       1414.14141414, 1449.49494949, 1484.84848485, 1520.2020202 ,
       1555.55555556, 1590.90909091, 1626.26262626, 1661.61616162,
       1696.96969697, 1732.32323232, 1767.67676768, 1803.03030303,
       1838.38383838, 1873.73737374, 1909.09090909, 1944.44444444,
       1979.7979798 , 2015.15151515, 2050.50505051, 2085.85858586,
       2121.21212121, 2156.56565657, 2191.91919192, 2227.27272727,
       2262.62626263, 2297.97979798, 2333.33333333, 2368.68686869,
       2404.04040404, 2439.39393939, 2474.74747475, 2510.1010101 ,
       2545.45454545, 2580.80808081, 2616.16161616, 2651.51515152,
       2686.86868687, 2722.22222222, 2757.57575758, 2792.92929293,
       2828.28282828, 2863.63636364, 2898.98989899, 2934.34343434,
       2969.6969697 , 3005.05050505, 3040.4040404 , 3075.75757576,
       3111.11111111, 3146.46464646, 3181.81818182, 3217.17171717,
       3252.52525253, 3287.87878788, 3323.23232323, 3358.58585859,
       3393.93939394, 3429.29292929, 3464.64646465, 3500.        ])</span>
    </div>

    

                            </div>
                            <div id="RamanCalibration.show" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanCalibration.show">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">show</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the calibration data points and the associated model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_x</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots the calibration data points and the associated model.</p>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Curve">Curve</a></dt>
                                <dd id="RamanCalibration.plot" class="function"><a href="#Curve.plot">plot</a></dd>
                <dd id="RamanCalibration.normalize" class="function"><a href="#Curve.normalize">normalize</a></dd>
                <dd id="RamanCalibration.smooth" class="function"><a href="#Curve.smooth">smooth</a></dd>
                <dd id="RamanCalibration.x_crop" class="function"><a href="#Curve.x_crop">x_crop</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RamanMTF">
                                <div class="attr class">
        <a class="headerlink" href="#RamanMTF">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RamanMTF</span><wbr>(<span class="base"><a href="#Curve">Curve</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RamanMTF</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing an MTF model in Fourier space. The reciprocal coordinate is 1/pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;Nyquist frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
        <span class="c1"># k + CTF come as 1024 px vectors.</span>
</pre></div>

        </details>

            <div class="docstring"><p>Object containing an MTF model in Fourier space. The reciprocal coordinate is 1/pixels.</p>
</div>


                            <div id="RamanMTF.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanMTF.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RamanMTF</span><span class="signature">(data)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;Nyquist frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
        <span class="c1"># k + CTF come as 1024 px vectors.</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>data : pandas DataFrame</p>

<blockquote>
  <p>Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</p>
</blockquote>

<p>x_column_name : str</p>

<blockquote>
  <p>Name of the column holding the x data.</p>
</blockquote>

<p>y_column_name : str</p>

<blockquote>
  <p>Name of the column holding the y data.  </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Curve">Curve</a></dt>
                                <dd id="RamanMTF.plot" class="function"><a href="#Curve.plot">plot</a></dd>
                <dd id="RamanMTF.normalize" class="function"><a href="#Curve.normalize">normalize</a></dd>
                <dd id="RamanMTF.smooth" class="function"><a href="#Curve.smooth">smooth</a></dd>
                <dd id="RamanMTF.x_crop" class="function"><a href="#Curve.x_crop">x_crop</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RamanCTF">
                                <div class="attr class">
        <a class="headerlink" href="#RamanCTF">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RamanCTF</span><wbr>(<span class="base"><a href="#Curve">Curve</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RamanCTF</span><span class="p">(</span><span class="n">Curve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing an MTF model in Fourier space. The reciprocal coordinate is 1/x units.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;spatial frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
        <span class="c1"># k + CTF come as 1024 px vectors.</span>
</pre></div>

        </details>

            <div class="docstring"><p>Object containing an MTF model in Fourier space. The reciprocal coordinate is 1/x units.</p>
</div>


                            <div id="RamanCTF.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RamanCTF.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RamanCTF</span><span class="signature">(data)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;spatial frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
        <span class="c1"># k + CTF come as 1024 px vectors.</span>
</pre></div>

        </details>

            <div class="docstring"><h2 id="parameters">Parameters</h2>

<p>data : pandas DataFrame</p>

<blockquote>
  <p>Data is imported as a DataFrame. This can come from common data formats such as csv or Excel.</p>
</blockquote>

<p>x_column_name : str</p>

<blockquote>
  <p>Name of the column holding the x data.</p>
</blockquote>

<p>y_column_name : str</p>

<blockquote>
  <p>Name of the column holding the y data.  </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>None.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Curve">Curve</a></dt>
                                <dd id="RamanCTF.plot" class="function"><a href="#Curve.plot">plot</a></dd>
                <dd id="RamanCTF.normalize" class="function"><a href="#Curve.normalize">normalize</a></dd>
                <dd id="RamanCTF.smooth" class="function"><a href="#Curve.smooth">smooth</a></dd>
                <dd id="RamanCTF.x_crop" class="function"><a href="#Curve.x_crop">x_crop</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="MetaData">
                                <div class="attr class">
        <a class="headerlink" href="#MetaData">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">MetaData</span><wbr>(<span class="base">builtins.dict</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MetaData</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object containing meta data as a dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
    <span class="c1"># Can be loaded or generated as dict, independently from data</span>
</pre></div>

        </details>

            <div class="docstring"><p>Object containing meta data as a dict.</p>
</div>


                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.dict</dt>
                                <dd id="MetaData.__init__" class="function">dict</dd>
                <dd id="MetaData.get" class="function">get</dd>
                <dd id="MetaData.setdefault" class="function">setdefault</dd>
                <dd id="MetaData.pop" class="function">pop</dd>
                <dd id="MetaData.popitem" class="function">popitem</dd>
                <dd id="MetaData.keys" class="function">keys</dd>
                <dd id="MetaData.items" class="function">items</dd>
                <dd id="MetaData.values" class="function">values</dd>
                <dd id="MetaData.update" class="function">update</dd>
                <dd id="MetaData.fromkeys" class="function">fromkeys</dd>
                <dd id="MetaData.clear" class="function">clear</dd>
                <dd id="MetaData.copy" class="function">copy</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="spectrum_to_frame">
                            <div class="attr function"><a class="headerlink" href="#spectrum_to_frame">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">spectrum_to_frame</span><span class="signature">(spectrum)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">spectrum_to_frame</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a spectrum to a *DataFrame* with a single row.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrum : Spectrum, RamanSpectrum or RamanChada</span>
<span class="sd">        &gt; Spectrum to be converted</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame</span>
<span class="sd">        &gt; DataFrame with a single row.</span>
<span class="sd">        For details, see *ramanchada.classes.RamanGroup*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="s1">&#39;meta&#39;</span><span class="p">):</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="s1">&#39;intensity&#39;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">column_name</span><span class="p">:</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">})</span>
    <span class="n">D</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x</span>
    <span class="n">D</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span>
    <span class="n">D</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;y_label&#39;</span><span class="p">:</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">y_label</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span>
</pre></div>

        </details>

            <div class="docstring"><p>Converts a spectrum to a <em>DataFrame</em> with a single row.</p>

<h2 id="parameters">Parameters</h2>

<p>spectrum : Spectrum, RamanSpectrum or RamanChada</p>

<blockquote>
  <p>Spectrum to be converted</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>DataFrame</p>

<blockquote>
  <p>DataFrame with a single row.
      For details, see <em><a href="#RamanGroup">ramanchada.classes.RamanGroup</a></em></p>
</blockquote>
</div>


                </section>
                <section id="spectrum_to_series">
                            <div class="attr function"><a class="headerlink" href="#spectrum_to_series">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">spectrum_to_series</span><span class="signature">(spectrum)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">spectrum_to_series</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a spectrum to a pandas *Series*.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrum : Spectrum, RamanSpectrum or RamanChada</span>
<span class="sd">        &gt; Spectrum to be converted</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.Series</span>
<span class="sd">        &gt; Series with Raman shifts as index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;Original file&#39;</span><span class="p">])</span>
    <span class="n">S</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x</span>
    <span class="n">S</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">x_label</span>
    <span class="k">return</span> <span class="n">S</span>
</pre></div>

        </details>

            <div class="docstring"><p>Converts a spectrum to a pandas <em>Series</em>.</p>

<h2 id="parameters">Parameters</h2>

<p>spectrum : Spectrum, RamanSpectrum or RamanChada</p>

<blockquote>
  <p>Spectrum to be converted</p>
</blockquote>

<h2 id="returns">Returns</h2>

<p>pandas.Series</p>

<blockquote>
  <p>Series with Raman shifts as index.</p>
</blockquote>
</div>


                </section>
                <section id="line_to_spectrum">
                            <div class="attr function"><a class="headerlink" href="#line_to_spectrum">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">line_to_spectrum</span><span class="signature">(DF, no_line)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">line_to_spectrum</span><span class="p">(</span><span class="n">DF</span><span class="p">,</span> <span class="n">no_line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the specified row of a *DataFrame* to a *Spectrum*.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    DF : DataFrame</span>
<span class="sd">        &gt; *pandas.DataFrame* structured as described in *ramanchada.classes.RamanGroup*</span>
<span class="sd">    </span>
<span class="sd">    no_line : int</span>
<span class="sd">        &gt; Row index to be converted </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ramanchada.classes.Spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">no_line</span><span class="p">]</span>
    <span class="n">S</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
    <span class="n">S</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">Spectrum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">x_column_name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">y_column_name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Converts the specified row of a <em>DataFrame</em> to a <em>Spectrum</em>.</p>

<h2 id="parameters">Parameters</h2>

<p>DF : DataFrame</p>

<blockquote>
  <p><em>pandas.DataFrame</em> structured as described in <em><a href="#RamanGroup">ramanchada.classes.RamanGroup</a></em></p>
</blockquote>

<p>no_line : int</p>

<blockquote>
  <p>Row index to be converted </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p><a href="#Spectrum">ramanchada.classes.Spectrum</a></p>
</div>


                </section>
                <section id="process_DF">
                            <div class="attr function"><a class="headerlink" href="#process_DF">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">process_DF</span><span class="signature">(DF, method, *args, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">process_DF</span><span class="p">(</span><span class="n">DF</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a single pre-processing step to each row of a *DataFrame*.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : str</span>
<span class="sd">        &gt; Name of *RamanChada* method to be applied.</span>
<span class="sd">        For details, refer to *ramanchada.classes.RamanChada*.</span>
<span class="sd">        </span>
<span class="sd">    *args : str of number</span>
<span class="sd">        &gt; Non-keyword parameters for method</span>

<span class="sd">    **kwargs</span>
<span class="sd">        &gt; Keyword parameters for method   </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    *pandas.DataFrame*</span>
<span class="sd">        &gt; Processed *DataFrame*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DF</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">line_to_spectrum</span><span class="p">(</span><span class="n">DF</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">DF_proc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">DF_proc</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span>
    <span class="n">DF_proc</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">DF_proc</span>
</pre></div>

        </details>

            <div class="docstring"><p>Applies a single pre-processing step to each row of a <em>DataFrame</em>.</p>

<h2 id="parameters">Parameters</h2>

<p>method : str</p>

<blockquote>
  <p>Name of <em>RamanChada</em> method to be applied.
      For details, refer to <em><a href="#RamanChada">ramanchada.classes.RamanChada</a></em>.</p>
</blockquote>

<p>*args : str of number</p>

<blockquote>
  <p>Non-keyword parameters for method</p>
</blockquote>

<p>**kwargs</p>

<blockquote>
  <p>Keyword parameters for method   </p>
</blockquote>

<h2 id="returns">Returns</h2>

<p><em>pandas.DataFrame</em></p>

<blockquote>
  <p>Processed <em>DataFrame</em></p>
</blockquote>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>